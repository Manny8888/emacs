#+author: J. Alexander Branham
#+STARTUP: indent
#+title: Emacs settings
* Intro
This file contains my Emacs configuration. I usually run Emacs as a daemon using a [[http://git.savannah.gnu.org/cgit/emacs.git/commit/?id=181bd848eb9662759f076b31a32f6588e9eb58b4][systemd service]]; the configuration is loaded upon login. To start a new frame, I call =emacsclient -c=. I've setup a desktop file to make that easier (and so I don't have to fire up a terminal to run Emacs). This seems to work better if all the packages are installed already, which is the case unless my =elpa/= folder got deleted or I'm setting up a new machine. To do that, I can just stop the systemd service and start Emacs normally.
* Behavior
  Change some of emacs's defaults because they suck:
  #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-message t ; disable start screen
          font-lock-maximum-decoration t) ; lots of color
  #+END_SRC

  I use ~desktop-clear~ to get rid of buffers and other things every now and then. Let's bind it to f12:

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "<f12>") #'desktop-clear)
  #+END_SRC

  C-x C-c is originally bound to kill emacs. I accidentally type this from time to time which is super-frustrating. Get rid of it:

  #+BEGIN_SRC emacs-lisp
    (global-unset-key (kbd "C-x C-c"))
  #+END_SRC
  
  In my world, =C-z= is undo, not minimize emacs:

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-z") #'undo)
  #+END_SRC

    I don't work much with emacs-lisp, so the scratch buffer shouldn't be in emacs-lisp mode:

    #+BEGIN_SRC emacs-lisp
      (setq initial-major-mode #'org-mode
            initial-scratch-message "# This buffer is for notes you don't want to save\n\n")
    #+END_SRC

    Ignore file case when trying to find stuff:

    #+BEGIN_SRC emacs-lisp
      (setq read-file-name-completion-ignore-case t)
    #+END_SRC

    Delete my files by moving them to the trash. I'm human and occasionally delete things that I actually want later:

    #+BEGIN_SRC emacs-lisp
      (setq delete-by-moving-to-trash t)
    #+END_SRC

Finally, I set up a cache folder in my =.emacs.d= folder so that it's not quite as crowded:

#+BEGIN_SRC emacs-lisp
  (defvar my/emacs-cache (concat user-emacs-directory ".cache/")
    "Folder to store cache files in.

  Should end with a forward slash.")
#+END_SRC

Save a few misc files in the =.cache= directory:

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat my/emacs-cache "customize.el"))
  (setq bookmark-default-file (concat my/emacs-cache "bookmarks"))
  (setq recentf-save-file (concat my/emacs-cache "recentf"))
  (setq nsm-settings-file (concat my/emacs-cache "network-security.data"))
#+END_SRC

** Exec path from shell
This ensures Emacs has the same PATH as the rest of my system:


#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :if (or (eq system-type 'darwin)
            (eq system-type 'gnu/linux))
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

** UTF-8
   Pretty please use utf-8 for all the things:

   #+BEGIN_SRC emacs-lisp
     (set-language-environment "UTF-8")
     (prefer-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-buffer-file-coding-system 'utf-8)
     (set-default-coding-systems 'utf-8)
   #+END_SRC

** Info+
Emacs' info manual is /amazing/. This makes it even better.
#+BEGIN_SRC emacs-lisp
  (use-package info+
    :defer t
    :ensure t
    :after info)
#+END_SRC

** Theme
   By default, emacs starts with a blindingly white theme. Let's get rid of that pronto.
   #+BEGIN_SRC emacs-lisp
     (use-package spacemacs-theme
       :ensure t
       :defer t
       :init
       (defvar my/theme 'spacemacs-dark
         "The theme I'm using.")
       (defun my/load-theme (frame)
         (select-frame frame)
         (load-theme my/theme t))

       (if (daemonp)
           (add-hook 'after-make-frame-functions #'my/load-theme)
         (load-theme my/theme t)))
   #+END_SRC
** Highlight numbers
I like to see numbers in code:
#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers          
    :ensure t
    :commands (highlight-numbers-mode)
    :init
    (add-hook 'prog-mode-hook #'highlight-numbers-mode)
    (add-hook 'ess-mode-hook #'highlight-numbers-mode))
#+END_SRC

** Color words describing colors
Rainbow-mode makes it so that for example #0000ff is displayed in white with a blue background. 

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :defer 10
    :config
    (add-hook 'prog-mode-hook #'rainbow-mode)
    (add-hook 'ess-mode-hook #'rainbow-mode)
    (add-hook 'text-mode-hook #'rainbow-mode))
#+END_SRC

** Scrolling
   Emacs has some awful scrolling by default. This gets rid of that. 

   #+BEGIN_SRC emacs-lisp
     (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ; one line at a time
     (setq mouse-wheel-progressive-speed nil) ; don't accelerate scrolling
     (setq mouse-wheel-follow-mouse 't) ; scroll window under mouse
     (setq scroll-step 1) ; keyboard scroll one line at a time
     (setq scroll-preserve-screen-position t)
     (setq scroll-conservatively 101)
     (setq view-read-only t) ; open read only buffers in view-mode
     ;; the defaults C-v and M-v scroll a full page, which is too much.
     ;; rebind to a half page:
     (use-package view
       :bind
       ("C-v" . View-scroll-half-page-forward)
       ("M-v" . View-scroll-half-page-backward))
   #+END_SRC

   This provides a visual cue whenever Emacs scrolls so it's easier to keep my place:

   #+BEGIN_SRC emacs-lisp
     (use-package on-screen
       :ensure t
       :config
       (on-screen-global-mode))
   #+END_SRC

** Smart parens
   I'm not good at keeping track of parentheses. This makes me slightly better at it. It also keeps track of other things that should "match" like {}, [], "", ``'' (in latex mode), etc.

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
       :ensure t
       :diminish smartparens-mode
       :commands (smartparens-global-strict-mode)
       :bind
       ("C-M-a" . sp-beginning-of-sexp)
       ("C-M-e" . sp-end-of-sexp)
       ("M-]" . sp-unwrap-sexp) ; C-M-SPC is bound to mark-sexp
       :init
       (require 'smartparens-config)
       :config
       (add-hook 'inferior-ess-mode-hook #'smartparens-strict-mode)
       (smartparens-global-strict-mode)
       (show-smartparens-global-mode))
   #+END_SRC

** PDF viewer
   I like emacs, so why not view PDFs in it? Build the server when it asks - this may take a second.

   NOTE: ~pdf-tools~ only officially supports gnu/linux operating systems. I think that it will work on macs as well, but you may have to finagle it a bit. Regardless, I tell emacs to only use it if the OS is linux based.

   #+BEGIN_SRC emacs-lisp 
     (when (eq system-type 'gnu/linux)
       (use-package pdf-tools
         :ensure t
         :config
         (pdf-tools-install t)
         (setq TeX-view-program-selection '((output-pdf "pdf-tools")))
         (setq TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))))
   #+END_SRC

** File finder (Dired)
   Emacs can act as your file finder/explorer. Dired is the built-in way to do this.

   #+BEGIN_SRC emacs-lisp
     (setq dired-auto-revert-buffer t)
     (setq dired-dwim-target t)
     (setq dired-recursive-copies (quote always))
     (setq dired-recursive-deletes (quote always))
     ;; Hide details (owner, permissions) in dired
     (add-hook 'dired-mode-hook
               (lambda () (dired-hide-details-mode 1)))
     (bind-key "l" #'dired-up-directory dired-mode-map)
   #+END_SRC

   Here I sort dired buffers with directories (folders) first, then everything else:

   #+BEGIN_SRC emacs-lisp
     (defadvice dired-readin (after dired-after-updating-hook first () activate)
       "Sort dired listings with directories first before adding marks."
       (save-excursion
         (let (buffer-read-only)
           (forward-line 2) ;; beyond dir. header
           (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
         (set-buffer-modified-p nil)))
   #+END_SRC

   This lets me make directories on the fly similar to =mkdir -p=. [[http://mbork.pl/2016-07-25_Making_directories_on_the_fly][Thanks!]]

   #+BEGIN_SRC emacs-lisp
     (defun make-parent-directory ()
       "Make sure the directory of `buffer-file-name' exists."
       (make-directory (file-name-directory buffer-file-name) t))

     (add-hook 'find-file-not-found-functions #'make-parent-directory)
   #+END_SRC
** Modeline
   The default modeline is nice enough, but this one is much better looking:

   #+BEGIN_SRC emacs-lisp
     (use-package spaceline-config
       :ensure spaceline
       :config
       (setq spaceline-window-numbers-unicode t)
       (spaceline-spacemacs-theme)
       (spaceline-helm-mode)
       (spaceline-info-mode)
       (spaceline-toggle-buffer-encoding-abbrev-off)
       (add-hook 'after-init-hook #'spaceline-toggle-minor-modes-off))
   #+END_SRC
   Also, we can substitute the [[http://fontawesome.io/icon/code-fork/][code fork]] from [[http://fontawesome.io/icon/code-fork/][font awesome]] (which you'll need to have installed) to have a pretty symbol instead of "git:branch"
#+BEGIN_SRC emacs-lisp
  (defun my-vc-git-mode-line-string (orig-fn &rest args)
    "Replace Git in modeline with font-awesome git icon via ORIG-FN and ARGS."
    (let ((str (apply orig-fn args)))
      (concat [#xF126] ":" (substring-no-properties str 4))))

  (advice-add #'vc-git-mode-line-string :around #'my-vc-git-mode-line-string)
#+END_SRC

*** Mode icons
I can make the modeline a little fancier by using icons like the [[http://orgmode.org/img/org-mode-unicorn-logo.png][org mode icon]] rather than text like "Org":
#+BEGIN_SRC emacs-lisp
  (use-package mode-icons
    :ensure t
    :config
    (mode-icons-mode))
#+END_SRC
** Which-key
   [[https://github.com/justbur/emacs-which-key][Which key]] shows key bindings for incomplete commands (prefixes).

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :ensure t
       :diminish which-key-mode
       :commands which-key-mode
       :defer 10
       :config
       (which-key-mode))
   #+END_SRC

** Window switching 
I can use =window-numbering= to quickly jump from window to window

   #+BEGIN_SRC emacs-lisp
     (use-package window-numbering
       :ensure t
       :config
       (window-numbering-mode))
   #+END_SRC

** Frame management

#+BEGIN_SRC emacs-lisp
  (if (daemonp)
      (progn
        (defun my/save-if-last-frame (frame)
          (when (eq 1 (cl-count-if
                       (lambda (f)
                         (eq
                          (frame-parameter f 'display)
                          (frame-parameter frame 'display)))
                       (visible-frame-list)))
            (save-some-buffers)))

        (add-to-list 'delete-frame-functions #'my/save-if-last-frame)))

#+END_SRC

** Transpose frame
I can use this package to swap the window layout easily:

#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :ensure t
    :commands (transpose-frame))
#+END_SRC

** Server
   Start the server:
   #+BEGIN_SRC emacs-lisp
     (use-package server
       :if window-system
       :config
       (unless (server-running-p)
         (add-hook 'after-init-hook #'server-start t)))
   #+END_SRC
** Crux
   [[https://github.com/bbatsov/crux/blob/master/crux.el][Crux]] is a collection of useful extensions. Here I bind some of the more useful functions:

   #+BEGIN_SRC emacs-lisp
     (use-package crux
       :ensure t
       :diminish abbrev-mode
       :bind
       (("C-x i" . crux-ispell-word-then-abbrev)
        ("C-c e" . crux-sudo-edit)
        :map prog-mode-map
        ("C-a" . crux-move-beginning-of-line))
       :init
       (setq abbrev-file-name (concat my/emacs-cache "abbrev_defs"))
       :config
       (setq save-abbrevs 'silently)
       (setq-default abbrev-mode t))
   #+END_SRC

** Avy
   Avy lets me jump anywhere on the screen super quickly. Just =M-S=, then one letter to jump to wherever you want:
   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :ensure t
       :bind
       ("C-M-g" . avy-goto-char-timer))
   #+END_SRC

** Help windows
   You can use =C-h f=, =C-h v= and others to read docs for functions, variables, etc. This makes emacs switch focus to these windows:

   #+BEGIN_SRC emacs-lisp
     (setq help-window-select t)
   #+END_SRC
** popwin
   [[https://github.com/m2ym/popwin-el][popwin]] describes itself as freeing me from the hell of annoying buffers. Let's see if that's true:

   #+BEGIN_SRC emacs-lisp
     (use-package popwin
       :ensure t
       :config
       (popwin-mode 1))
   #+END_SRC

** Passwords
   I use [[https://www.passwordstore.org/][pass]] to manage all my passwords and login info. This lets me easily access it from within emacs:

   #+BEGIN_SRC emacs-lisp
     (use-package password-store
       :ensure t
       :if (executable-find "pass")
       :commands (password-store-copy password-store-edit password-store-generate)
       :bind
       ("M-s p" . hydra-password-store/body)
       :config
       (setq password-store-password-length 20)
       (with-eval-after-load "hydra"
         (defhydra hydra-password-store ()
           "
     _c_: copy,      _e_: edit,   _n_: new
     _F_: pull,      _p_: push
     "
           ("F" (lambda () (interactive) (async-shell-command "pass git pull")))
           ("p" (lambda () (interactive) (async-shell-command "pass git push")))
           ("c" password-store-copy :exit t)
           ("e" password-store-edit :exit t)
           ("n" password-store-generate :exit t))))
   #+END_SRC
** Try
   This package lets me try out other packages before installing them by installing them to tmp:


   #+BEGIN_SRC emacs-lisp
     (use-package try
       :ensure t
       :commands (try))
   #+END_SRC

** Undo-tree
   Emacs undo system is incredibly powerful but a bit confusing. This package has a great visualization system that helps out, bound to =C-x u= by default. Originally, =C-z= minimizes emacs. That's stupid, so let's make it undo instead like a sane person. Note that redo is bound

   I've turned this off, as I'm experiencing a weird bug and trying to find the cause!

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :ensure t
       :diminish undo-tree-mode
       :init
       (global-undo-tree-mode)
       :config
       (setq undo-tree-visualizer-timestamps t)
       (setq undo-tree-visualizer-diff t))
   #+END_SRC

** Hydra
[[https://github.com/abo-abo/hydra][Hydra]] is a nice package that lets you set up menus for related (or not) commands. 

   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :ensure t)
   #+END_SRC

** Move buffers
   Sometimes the buffers are in the wrong places. This lets me move them around.

   #+BEGIN_SRC emacs-lisp
     (use-package buffer-move
       :ensure t
       :bind
       ("M-S-<up>" . buf-move-up)
       ("M-S-<down>" . buf-move-down)
       ("M-S-<left>" . buf-move-left)
       ("M-S-<right>" . buf-move-right)
       :config
       (setq buffer-move-behavior 'move))
   #+END_SRC

   Here's a quick [[https://github.com/abo-abo/hydra][hydra]] that I wrote to quickly move buffers from window to window:

   #+BEGIN_SRC emacs-lisp
     (defhydra hydra-window ()
       "window management"
       ("l" buf-move-left "left")
       ("r" buf-move-right "right")
       ("d" buf-move-down "down")
       ("u" buf-move-up "up"))
     (global-set-key (kbd "C-c m b") 'hydra-window/body)
   #+END_SRC

** Auto indent

   [[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent mode]] keeps code indented automatically, even after rearranging stuff:

   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent
       :ensure t
       :config
       (global-aggressive-indent-mode)
       (add-to-list 'aggressive-indent-excluded-modes 'inferior-ess-mode))
   #+END_SRC

** System packages
   This is a collection of functions I wrote to help me manage installed system packages with emacs. You can find the package [[https://github.com/jabranham/system-packages][on github]]

   #+BEGIN_SRC emacs-lisp
     (use-package system-packages
       :load-path "~/code/system-packages"
       :bind ("<f5>" . hydra/system-packages/body) 
       :config
       (defhydra hydra/system-packages ()
         "Manage system packages"
         ("i" system-packages-install "install" :exit t)
         ("s" system-packages-search "search" :exit t)
         ("U" system-packages-uninstall "uninstall" :exit t)
         ("u" system-packages-update "update" :exit t)
         ("l" system-packages-list-installed-packages "list installed" :exit t)
         ("O" system-packages-remove-orphaned "remove orphans" :exit t)))
   #+END_SRC

** Multiple cursors 
   Emacs can support multiple cursors. I don't use this much, but it's super handy when I do need it:
   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :init
       (setq mc/list-file (concat my/emacs-cache "mc-lists.el"))
       :bind
       ("C-c m c l" . mc/edit-lines)
       ("C-c m c a" . mc/mark-all-like-this))
   #+END_SRC
** Expand region
I can use ~C-=~ to expand the region incrementally:

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-=" . er/expand-region))
#+END_SRC
** Browser
Use Emacs' built in =eww= broswer by default. If a webpage requires more, I can switch to the system default by tapping =&=:

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function
        '((".*login.utexas.*" . browse-url-firefox)
          (".*utdirect.*utexas.*" . browse-url-firefox)
          (".*github.*" . browse-url-firefox)
          (".*youtube.*" . browse-url-firefox)
          (".*youtu.be*" . browse-url-firefox)
          ("." . eww-browse-url)))
#+END_SRC

=eww-lnum= makes following links a little easier:
#+BEGIN_SRC emacs-lisp
  (use-package eww-lnum
    :ensure t
    :after eww
    :bind
    (:map eww-mode-map
          ("f" . eww-lnum-follow)
          ("F" . eww-lnum-universal)))
#+END_SRC

By default, =M-s M-w= searches for text in the region. I change it to search for text in region if active, prompt otherwise:
#+BEGIN_SRC emacs-lisp
  (defun jab/eww-search (orig-fun &rest args)
    (if (region-active-p) (apply orig-fun args)
      (eww (read-string "Query: "))))
  (advice-add 'eww-search-words :around #'jab/eww-search)
#+END_SRC
** Tramp 
Store tramp files in the cache:

#+BEGIN_SRC emacs-lisp
  (setq tramp-persistency-file-name (concat my/emacs-cache "tramp"))
#+END_SRC

** Miscellaneous 
   Here are a bunch of things I want emacs to do (or not) but don't seem to fit in other sections.

   For when I need lots of text: 
   #+BEGIN_SRC emacs-lisp
     (defun lorem ()
       "Insert a lorem ipsum."
       (interactive)
       (insert "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do "
               "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim"
               "ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut "
               "aliquip ex ea commodo consequat. Duis aute irure dolor in "
               "reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla "
               "pariatur. Excepteur sint occaecat cupidatat non proident, sunt in "
               "culpa qui officia deserunt mollit anim id est laborum."))
   #+END_SRC

*** Zooming
Everywhere else you can zoom with =C--= and =C-+=. Let's make Emacs follow that convention:
#+BEGIN_SRC emacs-lisp
  (bind-key "C-+" 'text-scale-increase)
  (bind-key "C--" 'text-scale-decrease)
#+END_SRC
*** Enable disabled commands
Emacs thinks that some new users may find some commands confusing, so they're disabled by default. I use these every now and then, so let's enable them by default: 

#+BEGIN_SRC emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

*** Mouse avoid
Oftentimes the mouse just gets in the way. Since I rarely use the mouse, let's banish it to the upper right corner whenever I type a key in Emacs:

#+BEGIN_SRC emacs-lisp
  (mouse-avoidance-mode 'banish)
#+END_SRC

*** Prettify symbols
Prettify-symbols-mode will replace some symbols (like "lambda") with their prettier cousins (like \lambda). 

#+BEGIN_SRC emacs-lisp
  (setq prettify-symbols-unprettify-at-point 'right-edge)
  (global-prettify-symbols-mode)
#+END_SRC

*** Replace selected text
    Emacs by default doesn't replace selected text if you start typing over it. Since that's the behavior of virtually all other programs, let's make emacs do that too:

    #+BEGIN_SRC emacs-lisp
      (delete-selection-mode)
    #+END_SRC

*** Backup files
    I want emacs to make these, but don't want to clutter up my project folders with tons of backup files. Solution: put them in the ~.emacs.d/~ directory.
    #+BEGIN_SRC emacs-lisp
      (setq backup-directory-alist
            `(("." . ,(expand-file-name
                       (concat user-emacs-directory "backups")))))
    #+END_SRC
*** Blinking cursor & highlight line
    A blinking cursor gets kinda annoying, so get rid of it:

    #+BEGIN_SRC emacs-lisp
      (blink-cursor-mode -1)
    #+END_SRC

    Also, I like the current line to be highlighted. Makes it easy to see where I am:

    #+BEGIN_SRC emacs-lisp
      (global-hl-line-mode)
    #+END_SRC
*** Refresh buffers
    Emacs should refresh buffers automatically so if they've changed on disk the buffer will update. I want dired to do this, but don't ask me.

    #+BEGIN_SRC emacs-lisp
      (setq global-auto-revert-non-file-buffers t)
      (setq auto-revert-verbose nil)
      (global-auto-revert-mode 1)
    #+END_SRC

*** Resize windows
    We can resize windows now! 
     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
       (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
       (global-set-key (kbd "S-C-<down>") 'shrink-window)
       (global-set-key (kbd "S-C-<up>") 'enlarge-window)
     #+END_SRC
*** Move around quickly
    You can ~C-n~ and whatnot to go by line, but sometimes I want to move a bit more quickly than that. Using ~C-S-n~ will now let me:

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-S-n")
                      (lambda ()
                        (interactive)
                        (ignore-errors (next-line 5))))

      (global-set-key (kbd "C-S-p")
                      (lambda ()
                        (interactive)
                        (ignore-errors (previous-line 5))))

      (global-set-key (kbd "C-S-f")
                      (lambda ()
                        (interactive)
                        (ignore-errors (forward-char 5))))

      (global-set-key (kbd "C-S-b")
                      (lambda ()
                        (interactive)
                        (ignore-errors (backward-char 5))))
    #+END_SRC

*** Start maximized
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'default-frame-alist '(fullscreen . maximized))

    #+END_SRC

*** Better defaults 
    This is inspired by the [[https://github.com/technomancy/better-defaults][better defaults]] package, but I don't like everything in there.

    Yes, please save my place when opening/closing files: 

    #+BEGIN_SRC emacs-lisp
      (use-package saveplace
        :init
        (setq save-place-file (concat my/emacs-cache "places"))
        :config
        (save-place-mode))
    #+END_SRC

    Get rid of menu-bar, toolbar, and the scroll bars
    #+BEGIN_SRC emacs-lisp
      (menu-bar-mode -1)
      (tool-bar-mode -1)
      (scroll-bar-mode -1)
    #+END_SRC

    Don't ever use tabs. Always use spaces. 
    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil)
    #+END_SRC

    Emacs "kills" and "yanks" instead of cutting and pasting. Using this, we can ~C-w~ and that will kill the active region (whatever you have selected). If you haven't selected anything, it'll kill the line it's on.
    #+BEGIN_SRC emacs-lisp
      ;; http://emacs-fu.blogspot.co.uk/2009/11/copying-lines-without-selecting-them.html
      (defadvice kill-region (before slick-cut activate compile)
        "When called interactively with no active region, kill a single line instead."
        (interactive
         (if mark-active (list (region-beginning) (region-end))
           (list (line-beginning-position)
                 (line-beginning-position 2)))))
    #+END_SRC

    This will set the frame name to the name of the file, so you can see what file you've got selected in the menu bar.

    #+BEGIN_SRC emacs-lisp
      (setq frame-title-format
            '("Emacs - " (buffer-file-name "%f"
                                           (dired-directory dired-directory "%b"))))
    #+END_SRC

    Because I'm lazy, I want to just type y or n instead of spelling out yes/no.

    #+BEGIN_SRC emacs-lisp
      (fset 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

    Also, don't ask me when I try to create a new file. Just create it.

    #+BEGIN_SRC emacs-lisp
      (setq confirm-nonexistent-file-or-buffer nil)
    #+END_SRC

      We can use shift-mouse for selecting from point:

      #+BEGIN_SRC emacs-lisp
        (define-key global-map (kbd "<S-down-mouse-1>") 'mouse-save-then-kill)
      #+END_SRC

    Use regex searches by default:

    #+BEGIN_SRC emacs-lisp
      (setq search-default-mode t)
    #+END_SRC

    A few final modifications: 

    #+BEGIN_SRC emacs-lisp
      (setq   save-interprogram-paste-before-kill t
              apropos-do-all t
              mouse-yank-at-point t
              require-final-newline t
              visible-bell t
              load-prefer-newer t
              ediff-window-setup-function 'ediff-setup-windows-plain)
    #+END_SRC
* Auto completion
** Company mode
   Company mode provides autocompletion of text and code. 

   #+BEGIN_SRC emacs-lisp
     (use-package company 
       :ensure t
       :diminish company-mode
       :bind
       (:map company-active-map
             ("C-s" . company-search-candidates)
             ("<tab>" . company-complete-common-or-cycle)
             ("RET" . company-complete-selection)
             ("C-n" . company-select-next)
             ("C-p" . company-select-previous))
       :init
       (add-hook 'after-init-hook #'global-company-mode)
       :config
       (setq company-minimum-prefix-length 2)
       (use-package company-statistics
         :ensure t
         :config
         (setq company-statistics-file
               (concat my/emacs-cache "company-statistics-cache.el"))
         (company-statistics-mode))
       (use-package company-math
         :ensure t
         :config
         (add-to-list 'company-backends 'company-math-symbols-latex))
       (use-package company-quickhelp
         :ensure t
         :config
         (company-quickhelp-mode))
       (use-package company-flx
         :ensure t
         :init
         (with-eval-after-load 'company
           (company-flx-mode +1)))
       (use-package company-web-html
         :ensure company-web)
       (use-package company-shell
         :ensure t
         :config
         (add-to-list 'company-backends 'company-shell)))
   #+END_SRC
** Hippie expand

#+BEGIN_SRC emacs-lisp
  (use-package hippie-exp
    :bind
    ("M-/" . hippie-expand))
#+END_SRC

** Yasnippet 
   Yasnippet allows you to type an abbreviation and then expand it into a template. We can look at yasnippet's documentation [[https://github.com/capitaomorte/yasnippet][on github]].

   Yasnippet by default checks for snippets in two places: a path relative to yasnippet.el (these are the default snippets that come with the package). If I want to make my own, I can put then in ~.emacs.d/snippets~ and it should find them there as well.
  
   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :ensure t
       :diminish yas-minor-mode
       :after hippie-exp
       :init
       ;; disable yas minor mode map
       ;; use hippie-expand instead
       (setq yas-minor-mode-map (make-sparse-keymap))
       :config
       (push 'yas-hippie-try-expand hippie-expand-try-functions-list)
       (add-hook 'term-mode-hook (lambda () (yas-minor-mode -1)))
       (define-key yas-minor-mode-map (kbd "C-c &") nil)
       (yas-global-mode))
   #+END_SRC
* Functions
** Splitting windows
   These functions make splitting windows behave more like I want it to. This way, calling ~C-x 2~ or ~C-x 3~ both splits the window /and/ shows the last buffer.

   #+BEGIN_SRC emacs-lisp
     (defun my/vsplit-last-buffer (prefix)
       "Split the window vertically and display the previous buffer."
       (interactive "p")
       (split-window-vertically)
       (other-window 1 nil)
       (if (= prefix 1)
           (switch-to-next-buffer)))
     (defun my/hsplit-last-buffer (prefix)
       "Split the window horizontally and display the previous buffer."
       (interactive "p")
       (split-window-horizontally)
       (other-window 1 nil)
       (if (= prefix 1) (switch-to-next-buffer)))
     (bind-key "C-x 2" 'my/vsplit-last-buffer)
     (bind-key "C-x 3" 'my/hsplit-last-buffer)
   #+END_SRC
** Calc
   From [[https://www.reddit.com/r/emacs/comments/445w6s/whats_some_small_thing_in_your_dotemacs_that_you/][this reddit thread]]

   #+BEGIN_SRC emacs-lisp
     (defun my/calc-eval-region (arg)
       "Evaluate an expression in calc and communicate the result.

     If the region is active evaluate that, otherwise search backwards
     to the first whitespace character to find the beginning of the
     expression. By default, replace the expression with its value. If
     called with the universal prefix argument, keep the expression
     and insert the result into the buffer after it. If called with a
     negative prefix argument, just echo the result in the
     minibuffer."
       (interactive "p")
       (let (start end)
         (if (use-region-p)
             (setq start (region-beginning) end (region-end))
           (progn
             (setq end (point))
             (setq start (search-backward-regexp "\\s-\\|\n" 0 1))
             (setq start (1+ (if start start 0)))
             (goto-char end)))
         (let ((value (calc-eval (buffer-substring-no-properties start end))))
           (pcase arg
             (1 (delete-region start end))
             (4 (insert " = ")))
           (pcase arg
             ((or 1 4) (insert value))
             (-1 (message value))))))
   #+END_SRC
** Insert file name

This function ([[http://pragmaticemacs.com/emacs/insert-file-name/][credit]]) lets me insert a file name easily. Defaults to relative path, use the universal argument to get the absolute path.

   #+BEGIN_SRC emacs-lisp
     (defun my/insert-file-name (filename &optional args)
       "Insert name of file FILENAME into buffer after point.

       Prefixed with \\[universal-argument], expand the file name to
       its fully canocalized path.  See `expand-file-name'.

       Prefixed with \\[negative-argument], use relative path to file
       name from current directory, `default-directory'.  See
       `file-relative-name'.

       The default with no prefix is to insert the file name exactly as
       it appears in the minibuffer prompt."
       ;; Based on insert-file in Emacs -- ashawley 20080926
       (interactive "*fInsert file name: \nP")
       (cond ((eq '- args)
              (insert (expand-file-name filename)))
             ((not (null args))
              (insert (filename)))
             (t
              (insert (file-relative-name filename)))))
   #+END_SRC

** Go to this file
   It's nice to have a function to find this file quickly. Here's one:


   #+BEGIN_SRC emacs-lisp
     (defun my/find-emacs-file ()
       "Find my emacs org file"
       (interactive)
       (find-file (concat user-emacs-directory "emacs.org")))

     (global-set-key (kbd "<f11>") #'my/find-emacs-file)
   #+END_SRC
** Update arch repos
Use the fastest repo:

#+BEGIN_SRC emacs-lisp
  (defun update_arch_repos ()
    "Update pacman mirrorlist to use the fastest 5 mirrors."
    (async-shell-command "sudo reflector --sort rate --save /etc/pacman.d/mirrorlist -c 'United States' -f 5 -l 5"))
#+END_SRC
** Narrowing
Emacs has a great system to "narrow" a buffer to just a smaller bit. This is useful in a whole bunch of unexpected ways. For example, if a function will do something to a whole buffer but you only want to apply it to part, you can just narrow to that bit of the buffer. Or narrow just to one org subtree when you have a massive org document. The narrow commands are a bit confusing by default. This cleans them up a bit and makes it more intuitive to use. I got this from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][this post]] (modified a bit).
#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first. Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           (cond ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  ;; This line actually replaces Emacs' entire narrowing
  ;; keymap, that's how much I like this command. Only
  ;; copy it if that's what you want.
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (define-key LaTeX-mode-map "\C-xn"
                nil)))

#+END_SRC
* Helm

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :diminish helm-mode
    :bind
    (("M-x" . helm-M-x)
     ("C-x C-f" . helm-find-files)
     ("M-y" . helm-show-kill-ring)
     ("C-M-z" . helm-resume)
     ("C-x b" . helm-buffers-list)
     ("M-s M-g" . helm-google-suggest)
     :map helm-map
     ("<tab>" . helm-execute-persistent-action)
     ("C-i" . helm-execute-persistent-action)
     ("C-z" . helm-select-action))
    :init
    (progn
      (setq helm-adaptive-history-file (concat my/emacs-cache "helm-adaptive-history"))
      (require 'helm-config)
      )
    :config
    (when (executable-find "curl")
      (setq helm-net-prefer-curl t))
    (setq helm-split-window-default-side 'below)
    (setq helm-split-window-in-side-p t)
    (setq helm-display-header-line nil)
    (setq helm-echo-input-in-header-line t)
    (helm-autoresize-mode)
    (helm-mode))
#+END_SRC

** Helm and references (helm-bibtex)
   #+BEGIN_SRC emacs-lisp
     (use-package helm-bibtex
       :ensure t
       :init
       ;; Set up how keys should look - authoryear
       (setq bibtex-autokey-titleword-length 0
             bibtex-autokey-titleword-separator ""
             bibtex-autokey-titlewords 0
             bibtex-autokey-year-length 4
             bibtex-autokey-year-title-separator "")
       (setq bibtex-align-at-equal-sign t)
       (setq bibtex-files '("~/Dropbox/bibliography/references.bib"))
       (defun bibtex-generate-autokey ()
         "This overwrites the bibtex-generate-autokey function that comes with Emacs. 

       I want my keys to be formatted: authornameYEAR, then a letter if there is already an entry that matches authornameYEAR."
         (let* ((names (bibtex-autokey-get-names))
                (year (bibtex-autokey-get-year))
                (existing-keys (bibtex-parse-keys))
                key)
           (setq key (format "%s%s" names year))
           (let ((ret key))
             (cl-loop for c
                      from ?b to ?z
                      while (assoc ret existing-keys)
                      do (setq ret (format "%s%c" key c)))
             ret)))
       :config
       (setq bibtex-completion-bibliography "~/Dropbox/bibliography/references.bib"
             bibtex-completion-library-path "~/Dropbox/bibliography/bibtex-pdfs"
             bibtex-completion-notes-path "~/Dropbox/bibliography/notes.org"
             bibtex-completion-notes-template-one-file
             "\n* TODO ${year} - ${title}\n  :PROPERTIES:\n  :Custom_ID: ${=key=}\n  :AUTHOR: ${author}\n  :JOURNAL: ${journal}\n  :YEAR: ${year}\n  :VOLUME: ${volume}\n  :PAGES: ${pages}\n  :DOI: ${doi}\n  :URL: ${url}\n :END:\n"
             )
       (setq bibtex-completion-cite-commands '("autocite" "textcite" "citep" "citet" "citeauthor" "citeyear" "Citep" "Citet")))
   #+END_SRC

** Helm and makefiles
I can setup helm to deal with makefiles easily: 

#+BEGIN_SRC emacs-lisp
  (use-package helm-make
    :ensure t
    :bind
    ("C-c p c" . helm-make-projectile)
    :init
    ;; scroll the compile buffer just until an error occurs
    (setq compilation-scroll-output 'first-error))
#+END_SRC
* Projectile 
Projectile makes using projects easier in emacs. It also plays well with helm, so let's set that up.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :init
    (setq projectile-cache-file (concat my/emacs-cache "projectile.cache"))
    (setq projectile-known-projects-file (concat my/emacs-cache "projectile-bookmarks.eld"))
    :config
    (def-projectile-commander-method ?F
      "Git fetch."
      (magit-status)
      (call-interactively #'magit-fetch-current))
    (projectile-global-mode)
    (define-key projectile-command-map (kbd "c") #'helm-make-projectile)
    (use-package helm-projectile
      :ensure t
      :config
      (setq projectile-completion-system 'helm)
      (helm-projectile-on)))
   #+END_SRC

* Org
  Org mode is a great thing. I use it for writing academic papers, managing my schedule, managing my references and notes, writing presentations, writing lecture slides, and pretty much anything else. This file is written in org-mode.

  Define =C-c l= to =org-store-link=: 

  #+BEGIN_SRC emacs-lisp
    (define-key global-map "\C-cl" 'org-store-link)
  #+END_SRC

** Exporting
   HTML and latex shown by default, let's add markdown:

   #+BEGIN_SRC emacs-lisp
     (use-package ox-md)
   #+END_SRC

   This makes org export smart quotes so that it uses ~``word``~ style quotes for latex export:

   #+BEGIN_SRC emacs-lisp
     (setq org-export-with-smart-quotes t)
   #+END_SRC

   This lets me override all the export variables with a =#+BIND:= statement at the beginning of org-mode files for export:

   #+BEGIN_SRC emacs-lisp
     (setq org-export-allow-bind-keywords t)
   #+END_SRC

** Code blocks (org-babel)
   Org-babel is included in org. We just need to tell it which languages to load. And don't ask us if we're sure we want to run code blocks when we ~C-c C-c~. Finally, open the code block in the current window when we use ~C-'~

   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (latex . t)
        (python . t)
        (R . t)
        (shell . t)))
     (setq org-confirm-babel-evaluate nil)
     (setq org-src-window-setup 'current-window)
   #+END_SRC

*** Code block font locking
    This will make the contents of code blocks use the same font locking (syntax highlighting) as the major mode. It'll also make the tab key act like you want it to inside code blocks.

    #+BEGIN_SRC emacs-lisp
      (setq org-src-fontify-natively     t
            org-src-tab-acts-natively    t)
    #+END_SRC

*** Adding SRC blocks
    Here I define a function ([[https://github.com/vdemeester/emacs-config/blob/master/.emacs.d/emacs.org][thanks!]]) that lets me easily add and edit source blocks in org mode:

    #+BEGIN_SRC emacs-lisp
      (defun my/org-insert-src-block (src-code-type)
        "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
        (interactive
         (let ((src-code-types
                '("emacs-lisp" "python" "sh" "calc" "R" "latex" "org")))
           (list (completing-read "Source code type: " src-code-types))))
        (progn
          (insert (format "#+BEGIN_SRC %s\n" src-code-type))
          (newline-and-indent)
          (insert "#+END_SRC\n")
          (previous-line 2)
          (org-edit-src-code)))

      (define-key org-mode-map (kbd "C-c s a") 'my/org-insert-src-block)
    #+END_SRC

** References (org-ref) 
   I use org-ref to manage my references. 
   #+BEGIN_SRC emacs-lisp
     (use-package org-ref-core
       :ensure org-ref
       :bind*
       (("C-c C-r" . org-ref-helm-insert-cite-link)
        :map bibtex-mode-map
        ("C-c C-c" . org-ref-clean-bibtex-entry))
       :init
       (setq org-ref-completion-library 'org-ref-helm-bibtex)
       (setq org-ref-bibliography-notes "~/Dropbox/bibliography/notes.org"
             org-ref-default-bibliography '("~/Dropbox/bibliography/references.bib")
             org-ref-pdf-directory  "~/Dropbox/bibliography/bibtex-pdfs"
             org-ref-default-citation-link "autocite")
       (use-package org-ref)
       :config
       (defvar my/notes-template
         "* TODO %y - %t\n :PROPERTIES:\n  :Custom_ID: %k\n  :AUTHOR: %9a\n  :JOURNAL: %j\n  :YEAR: %y\n  :VOLUME: %v\n  :PAGES: %p\n  :DOI: %D\n  :URL: %U\n :END:\n")
       (setq org-ref-note-title-format my/notes-template)

       ;; Org-ref-bibtex is a package (contained in org-ref, so no need for
       ;; an =:ensure t=) that helps me manage my bib file(s). I add the
       ;; my/fix-journal-name function to always put in the full name of
       ;; the journal. I also add it to the cleaning hook so that it's
       ;; taken care of for me more or less automatically.
       (defun my/add-to-journal-list (element)
         "Add ELEMENT to `org-ref-bibtex-journal-abbreviations'"
         (push element org-ref-bibtex-journal-abbreviations))

       (mapc #'my/add-to-journal-list
             '(("APSR" "American Political Science Review" "Am Polit Sci Rev")
               ("APSR" "American Political Science Review" "The American Political Science Review")
               ("AJPS" "American Journal of Political Science" "Am Jour Polit Sci")
               ("AJPS" "American Journal of Political Science" "Am J Political Science")
               ("JOP" "Journal of Politics" "The Journal of Politics")
               ("JOP" "Journal of Politics" "J of Pol")
               ("jop" "Journal of Politics" "J of Pol")
               ("EPSR" "European Political Science Review" "Eur. Pol. Sci. Rev.") 
               ("JoC" "Journal of Communication" "J Communication") 
               ("PoP" "Perspectives on Politics" "Perspect. polit.")))

       (defun my/fix-journal-name (&optional key start end)
         "Replace journal name in a bibtex entry with the full name.
       The strings are defined in
       `org-ref-bibtex-journal-abbreviations'. The optional arguments
       KEY, START and END allow you to use this with
       `bibtex-map-entries'"
         (interactive)
         (bibtex-beginning-of-entry)
         (when
             (string= "article"
                      (downcase
                       (cdr (assoc "=type=" (bibtex-parse-entry)))))
           (let* ((initial-names (mapcar
                                  (lambda (row)
                                    (cons  (nth 0 row) (nth 1 row)))
                                  org-ref-bibtex-journal-abbreviations))
                  (abbrev-names (mapcar
                                 (lambda (row)
                                   (cons  (nth 2 row) (nth 1 row)))
                                 org-ref-bibtex-journal-abbreviations))
                  (journal (s-trim (bibtex-autokey-get-field "journal")))
                  (bstring (or
                            (cdr (assoc journal initial-names))
                            (cdr (assoc journal abbrev-names))))) 
             (when bstring
               (bibtex-set-field "journal" bstring)
               (bibtex-fill-entry)))))

       (add-hook 'org-ref-clean-bibtex-entry-hook #'my/fix-journal-name)

       ;; I needed to change the order of things in this function. Probably
       ;; safe to submit a PR but I'll wait a while to see if I get any odd
       ;; behavior
       (defun orcb-key ()
         "Replace the key in the entry."
         ;; first we delete the existing key
         (bibtex-beginning-of-entry)
         (re-search-forward bibtex-entry-maybe-empty-head)
         (if (match-beginning bibtex-key-in-head)
             (delete-region (match-beginning bibtex-key-in-head)
                            (match-end bibtex-key-in-head)))
         (let ((key (funcall org-ref-clean-bibtex-key-function
                             (bibtex-generate-autokey))))
           ;; check if the key is in the buffer
           (when (save-excursion
                   (bibtex-search-entry key))
             (save-excursion
               (bibtex-search-entry key)
               (bibtex-copy-entry-as-kill)
               (switch-to-buffer-other-window "*duplicate entry*")
               (bibtex-yank))
             (setq key (bibtex-read-key "Duplicate Key found, edit: " key)))
           (insert key)
           (kill-new key)))


       (use-package doi-utils)
       (use-package org-ref-isbn)
       (use-package org-ref-latex)
       ) ; ends use-package org-ref
   #+END_SRC

** Agenda 
   Here's where I set which files are added to org-agenda, which controls org's global todo list, scheduling, and agenda features. I use Dropbox to keep these files in sync across computers.

   #+BEGIN_SRC emacs-lisp
     (use-package org-agenda
       :bind
       (("C-c a" . org-agenda)
        ("C-'" . org-cycle-agenda-files))
       :init
       (setq org-directory "~/Dropbox/org/")
       ;; set up org agenda files for the agenda
       (setq org-agenda-files (list (concat org-directory "todo.org")
                                    "~/Dropbox/bibliography/notes.org"))
       ;; remove C-c [ from adding org file to front of agenda
       (add-hook 'org-mode-hook
                 (lambda ()
                   (local-unset-key (kbd "C-c ["))))
       :config
       (setq org-agenda-skip-deadline-if-done t ; remove done deadlines from agenda
             org-agenda-skip-scheduled-if-done t ; remove done scheduled from agenda
             org-deadline-warning-days 3) ; warn me 3 days before a deadline
       (setq org-agenda-window-setup 'current-window ; use current window for agenda
             ;; restore previous config after I'm done
             org-agenda-restore-windows-after-quit t) 
       )
#+END_SRC

** Capture
I use org-capture to create short notes about all kinds of things. I can capture emails to remember for later, quick thoughts for later, RSS feeds (see [[Feed reader]]), really anything. 

#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :bind*
    ("C-c c" . org-capture)
    :init
    (setq org-default-notes-file (concat org-directory "todo.org")))
#+END_SRC
*** Org-eww
Org-eww lets me capture eww webpages with org-mode

#+BEGIN_SRC emacs-lisp
  (use-package org-eww)
#+END_SRC

*** Firefox
This line is necessary for the [[https://addons.mozilla.org/en-US/firefox/addon/org-mode-capture/][org-mode capture]] extension for Firefox. 

#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC

*** Capture templates
I use this function in the ledger capture templates to turn 2016-01-30 into 2016/01/30:
#+BEGIN_SRC emacs-lisp
  (defun my/read-date ()
    "Parse date for capturing ledger entries via org mode"
    (replace-regexp-in-string "-" "/" (org-read-date)))
#+END_SRC

And now for the capture templates themselves. It's a bit complicated, but [[http://orgmode.org/manual/Capture-templates.html][the manual]] does a great job explaining: 
  #+BEGIN_SRC emacs-lisp
    (setq org-capture-templates
          (quote (
                  ("s" "store" entry (file+headline (concat org-directory "todo.org") "Tasks")
                   "* TODO %?\n %a \n %i")
                  ("t" "task" entry (file+headline (concat org-directory "todo.org") "Tasks")
                   "* TODO %? \n %i")
                  ("x" "firefox" entry (file+headline (concat org-directory "todo.org") "Firefox")
                   "* TODO %c" :immediate-finish t)
                  ("l" "Ledger entries")
                  ("lc" "citi" plain (file "~/Dropbox/Finances/finances.ledger")
                   "%(my/read-date) %^{Payee} 
        Expenses:%^{Expense category}       $ %^{Amount}
        Liabilities:Citi mastercard" :empty-lines 1 :immediate-finish t)
                  ("ld" "pay with checking" plain (file "~/Dropbox/Finances/finances.ledger")
                   "%(my/read-date) %^{Payee} 
        Expenses:%^{Expense category}       $ %^{Amount}
        Assets:Checking" :empty-lines 1 :immediate-finish t))))
    #+END_SRC

** Refile
   Org-refile lets me quickly move around headings in org files. It plays nicely with org-capture, which I use to turn emails into TODOs easily (among other things, of course)

   #+BEGIN_SRC emacs-lisp
     (setq org-outline-path-complete-in-steps nil)
     (setq org-refile-allow-creating-parent-nodes (quote confirm))
     (setq org-refile-use-outline-path t)
     (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
   #+END_SRC

** Pomodoro
I can use =org-pomodoro= for a [[http://pomodorotechnique.com/][pomodoro]]. By default, it works in 25-minute work blocks and 5 minute breaks after. The fourth break is longer - 20 minutes by default.

I like to use system alerts, which are more visible than just sending it to Emacs's *Messages* buffer. I probably need to do this with add-to-list or something but this works for now:

#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :ensure t
    :commands (org-pomodoro)
    :config
    (setq alert-user-configuration (quote ((((:category . "org-pomodoro")) libnotify nil)))))
#+END_SRC

** org-projectile
[[https://github.com/IvanMalison/org-projectile][org-projectile]] nicely integrates org mode with projects tracked in projectile. 


#+BEGIN_SRC emacs-lisp
  (use-package org-projectile
    :ensure t
    :after org-capture
    :bind (("C-c n p" . org-projectile:project-todo-completing-read)
           ("C-c c" . org-capture))
    :config
    (progn
      (setq org-projectile:projects-file (concat org-directory "todo.org"))
      (add-to-list 'org-capture-templates (org-projectile:project-todo-entry "p"))))
#+END_SRC

** Better bullets

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (setq org-bullets-bullet-list '("◉" "○ ""►" "•" "•")) ; Default is '("◉" "○" "✸" "✿")
    (add-hook 'org-mode-hook #'org-bullets-mode))
#+END_SRC

** Misc
   Here are a few miscellaneous things that make org mode better. 
   #+BEGIN_SRC emacs-lisp
     (setq org-pretty-entities          t ; UTF8 all the things!  
           org-support-shift-select     t ; holding shift and moving point should select things
           org-enforce-todo-dependencies t ; can't finish parent before children
           org-enforce-todo-checkbox-dependencies t ; can't finish parent before children
           org-hide-emphasis-markers t ; make words italic or bold, hide / and *
           org-catch-invisible-edits 'error ; don't let me edit things I can't see
           org-startup-indented t) ; start with indentation setup
     (setq org-startup-with-inline-images t) ; show inline images
     (setq org-log-done t)
     (setq org-goto-interface (quote outline-path-completion))
     (setq org-ellipsis "⬎")
     (use-package htmlize
       :ensure t)
   #+END_SRC

   For whatever reason, I have to explicitely tell org how to open pdf links. I use pdf-tools, which is loaded in [[pdf viewer]]. If pdf-tools isn't installed, it will use doc-view (the default in emacs) instead.

   #+BEGIN_SRC emacs-lisp
     (setq org-file-apps
           '((auto-mode . emacs)
             ("\\.mm\\'" . default)
             ("\\.x?html?\\'" . default)
             ("\\.pdf\\'" . emacs)))

   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (setq org-image-actual-width '(300))
   #+END_SRC

   Make =C-a= and =C-e= work more like how I want: 
   
   #+BEGIN_SRC emacs-lisp
     (setq org-special-ctrl-a/e t)
   #+END_SRC

   Org can preview latex fragments with =C-c C-x C-l= but it uses dvipng by default. Let's switch it to imagemagick:
   #+BEGIN_SRC emacs-lisp
     (setq org-preview-latex-default-process 'imagemagick)
   #+END_SRC

* Shells
  
** Eshell 
Eshell is Emacs' built-in shell. You get UNIX-y goodness even on Windows machines, plus it can evaluate elisp. 

#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :defer t
    :commands (eshell)
    :config
    (setq eshell-cmpl-cycle-completions nil
          ;; auto truncate after 20k lines
          eshell-buffer-maximum-lines 20000
          ;; history size
          eshell-history-size 350
          ;; no duplicates in history
          eshell-hist-ignoredups t
          ;; my prompt is easy enough to see
          eshell-highlight-prompt nil
          ;; treat 'echo' like shell echo
          eshell-plain-echo-behavior t)
    (use-package eshell-prompt-extras
      :ensure t
      :init
      (setq eshell-prompt-function #'epe-theme-lambda)))
#+END_SRC

** Shell pop

#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :ensure t
    :bind ("C-c M-e" . shell-pop)
    :init
    (setq shell-pop-window-position 'bottom
          shell-pop-window-height 33
          shell-pop-full-span t
          shell-pop-shell-type '("eshell" "*eshell*" (lambda nil (eshell)))))
#+END_SRC

** Fix for dumb terminal
   Shell-mode uses a "dumb" terminal. Sometimes that's annoying, but this fixes the worst of that:

   #+BEGIN_SRC emacs-lisp
     (setenv "PAGER" "cat")
   #+END_SRC

** Make urls clickable

   #+BEGIN_SRC emacs-lisp
     (add-hook 'shell-mode-hook #'goto-address-mode)
     (add-hook 'eshell-mode-hook #'goto-address-mode)
   #+END_SRC

** Shell misc
   Here are a few miscellaneous settings for shell modes, including inferior ~R~ processes used by ~ESS~:
   #+BEGIN_SRC emacs-lisp
     (setq comint-scroll-to-bottom-on-input 'this)
     (setq comint-scroll-to-bottom-on-output t)
     (setq comint-move-point-for-output t)
   #+END_SRC
* R (with ESS)
  ESS (Emacs Speaks Statistics) is a [[http://ess.r-project.org/][great project]] and makes Emacs speak with R.

  #+BEGIN_SRC emacs-lisp
    (use-package ess-site 
      :ensure ess
      :pin melpa-stable
      :diminish eldoc-mode
      :bind
      (:map ess-mode-map
            ("C-a" . crux-move-beginning-of-line))
      :config
      (setq ess-nuke-trailing-whitespace-p t)
      (add-hook 'ess-mode-hook
                (lambda ()
                  (ess-set-style 'RStudio)))
      (setq ess-eval-visibly 'nowait) ; don't hog Emacs
      (setq ess-ask-for-ess-directory nil) ; don't ask for dir when starting a process
      (setq ess-eldoc-show-on-symbol t) ; show eldoc on symbol instead of only inside of parens
      (setq ess-use-ido nil) ; rely on helm instead of ido
      (setq ess-pdf-viewer-pref "emacsclient")
      (defun my/add-pipe ()
        "Adds a pipe operator %>% with one space to the left and then
    starts a newline with proper indentation"
        (interactive)
        (just-one-space 1)
        (insert "%>%")
        (ess-newline-and-indent))
      (define-key ess-mode-map (kbd "M-p") #'my/add-pipe))
  #+END_SRC

* Python
  The package is called python, the mode is python-mode: 
  #+BEGIN_SRC emacs-lisp
    (use-package python
      :mode ("\\.py\\'". python-mode)
      :interpreter "python")
  #+END_SRC

  Elpy is a ton of customizations for python. Note that I had to add it to ~package-archives~ in [[file:init.el]]. Load it up:

  #+BEGIN_SRC emacs-lisp 
    (use-package elpy
      :ensure t
      :pin melpa-stable
      :init
      (progn
        (elpy-enable))
      :config
      (when (require 'flycheck nil t)
        (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
        (add-hook 'elpy-mode-hook 'flycheck-mode)))
  #+END_SRC
* Stan
  Stan is a Bayesian modeling language. Emacs has a mode for it (of course!)

  #+BEGIN_SRC emacs-lisp
    (use-package stan-mode
      :ensure t
      :mode ("\\.stan\\'". stan-mode))
  #+END_SRC
* CSV files
Emacs can handle csv files with ease:
#+BEGIN_SRC emacs-lisp
  (use-package csv-mode
    :ensure t
    :mode (("\\.csv" . csv-mode)))
#+END_SRC

* Code and syntax checking
  Emacs can tell you magically if your code is wrong (or just ugly). Flycheck is a minor mode for this. Let's enable it globally.

  Flycheck can check your R code too, but you'll need to install the ~lintr~ package.

  #+BEGIN_SRC emacs-lisp
    (use-package flycheck ; checks for style and syntax
      :ensure t
      :diminish flycheck-mode
      :config
      (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
      (add-hook 'after-init-hook #'global-flycheck-mode))

  #+END_SRC

  Electric operator will turn ~a=10*5+2~ into ~a = 10 * 5 + 2~, so let's enable it for R:

  #+BEGIN_SRC emacs-lisp
    (use-package electric-operator
      :ensure t
      :config
      (setq electric-operator-R-named-argument-style 'spaced)
      (add-hook 'ess-mode-hook #'electric-operator-mode)
      (add-hook 'python-mode-hook #'electric-operator-mode))
  #+END_SRC
* Whitespace
  Whitespace is evil. Let's get rid of as much as possible. But we don't want to do this with files that already had whitespace (from someone else's project, for example). This mode will call ~whitespace-cleanup~ before buffers are saved (but smartly)!

  #+BEGIN_SRC emacs-lisp
    (use-package whitespace-cleanup-mode 
      :ensure t
      :diminish whitespace-cleanup-mode
      :config
      (add-hook 'prog-mode-hook #'whitespace-cleanup-mode)
      (add-hook 'ess-mode-hook #'whitespace-cleanup-mode))
  #+END_SRC

* Text Misc
I end sentences with a single space. 

  #+BEGIN_SRC emacs-lisp
    (setq sentence-end-double-space nil)
  #+END_SRC

  Turn on visual line mode for nice line wrapping

  #+BEGIN_SRC emacs-lisp
    (global-visual-line-mode)
  #+END_SRC

  Now that I've turned on ~visual-line-mode~, I want it to respect indentation. This does so:

  #+BEGIN_SRC emacs-lisp
    (use-package adaptive-wrap
      :ensure t
      :disabled t
      :config
      (when (fboundp 'adaptive-wrap-prefix-mode)
        (defun my-activate-adaptive-wrap-prefix-mode ()
          "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' simultaneously."
          (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))
        (add-hook 'visual-line-mode-hook #'my-activate-adaptive-wrap-prefix-mode)))
#+END_SRC

  =fill-paragraph= is nice, but emacs weirdly lacks a convenient way to unfill paragraphs once they're filled. This command ([[http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html][credit]]) fixes that.

    #+BEGIN_SRC emacs-lisp
      (defun endless/fill-or-unfill ()
        "Like `fill-paragraph', but unfill if used twice."
        (interactive)
        (let ((fill-column
               (if (eq last-command 'endless/fill-or-unfill)
                   (progn (setq this-command nil)
                          (point-max))
                 fill-column)))
          (call-interactively #'fill-paragraph)))

      (global-set-key [remap fill-paragraph]
                      #'endless/fill-or-unfill)
  #+END_SRC


  #+BEGIN_SRC emacs-lisp
    (defun dcaps-to-scaps ()
      "Convert word in DOuble CApitals to Single Capitals."
      (interactive)
      (and (= ?w (char-syntax (char-before)))
           (save-excursion
             (and (if (called-interactively-p)
                      (skip-syntax-backward "w")
                    (= -3 (skip-syntax-backward "w")))
                  (let (case-fold-search)
                    (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
                  (capitalize-word 1)))))

    (define-minor-mode dubcaps-mode
      "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
    Single Capitals as you type."
      :init-value nil
      :lighter (" DC")
      (if dubcaps-mode
          (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
        (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)))

    (add-hook 'text-mode-hook #'dubcaps-mode)
  #+END_SRC

* Markdown
  Markdown mode for Markdown editing! 

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode 
      :ensure t
      :commands (markdown-mode gfm-mode)
      :mode (("README\\.md\\'" . gfm-mode)
             ("\\.md\\'" . markdown-mode)
             ("\\.markdown\\'" . markdown-mode))
      :config
      (setq markdown-enable-math t))
  #+END_SRC

  Of course, markdown contains a yaml header, so we need yaml-mode as well:

  #+BEGIN_SRC emacs-lisp
    (use-package yaml-mode
      :ensure t
      :mode (("\\.yml\\'" . yaml-mode)))
  #+END_SRC

* LaTeX
  AuCTeX is better than the built in tex mode; let's use it. It's good out of the box, but I like to use latexmk so that I don't have to remember to rerun the file X times to get references right.

  #+BEGIN_SRC emacs-lisp
    (use-package tex-site
      :ensure auctex
      :config
      (add-hook 'LaTeX-mode-hook #'LaTeX-math-mode)
      (setq TeX-auto-save t
            TeX-parse-self t
            reftex-plug-into-AUCTeX t)
      (add-hook 'LaTeX-mode-hook 'reftex-mode)
      (add-hook 'LaTeX-mode-hook #'TeX-PDF-mode)
      (setq TeX-source-correlate-method 'synctex)
      (setq TeX-source-correlate-mode t)
      (eval-after-load "tex"
        '(add-to-list 'TeX-command-list '("latexmk" "latexmk -synctex=1 -pdf %s"
                                          TeX-run-compile nil t :help "Process file with latexmk")))
      (eval-after-load "tex"
        '(add-to-list 'TeX-command-list '("xelatexmk" "latexmk -synctex=1 -xelatex %s"
                                          TeX-run-compile nil t :help "Process file with xelatexmk")))
      (add-hook 'TeX-mode-hook (lambda () (setq TeX-command-default "latexmk")))
      ;; Some extra files generated by xelatexmk that I don't generally
      ;; want to keep:
      (push ".synctex.gz" dired-latex-unclean-extensions)
      (push ".fdb_latexmk" dired-latex-unclean-extensions)
      (push ".fls" dired-latex-unclean-extensions)
      ;; (push "\\.fdb_latexmk" LaTeX-clean-intermediate-suffixes)
      ;; (push "\\.fls" LaTeX-clean-intermediate-suffixes)
      ;; (push "\\.synctex.gz" LaTeX-clean-intermediate-suffixes)
      (setq TeX-clean-confirm nil)
      ;; turn on and enable folding by default:
      (add-hook 'LaTeX-mode-hook (lambda ()
                                   (TeX-fold-mode 1)
                                   (TeX-fold-buffer)))
      (setq TeX-fold-auto t)
      )
  #+END_SRC

  Finally, sometimes we want wordcounts. If I just want a quick snippet, I can run the following command. If I want more information, I can drop into a shell with ~C-c M-e~ (~shell-pop~) and run ~texcount my-file.tex~:

  #+BEGIN_SRC emacs-lisp
    (defun latex-word-count ()
      (interactive)
      (let* ((this-file (buffer-file-name))
             (word-count
              (with-output-to-string
                (with-current-buffer standard-output
                  (call-process "texcount" nil t nil "-brief" this-file)))))
        (string-match "\n$" word-count)
        (message (replace-match "" nil nil word-count))))
  #+END_SRC

** Reftex
I use =helm-bibtex= to manage my references, but ReFTeX is still great to have around for cross-references in latex files. 

You will need to change ~reftex-default-bibliography~ to wherever you keep your main .bib file.

#+BEGIN_SRC emacs-lisp
  (use-package reftex
    :commands turn-on-reftex
    :init
    (setq reftex-cite-format 
          '((?\C-m . "\\cite[]{%l}")
            (?t . "\\citet{%l}")
            (?p . "\\citep[]{%l}")
            (?a . "\\autocite{%l}")
            (?A . "\\textcite{%l}")
            (?P . "[@%l]")
            (?T . "@%l [p. ]")
            (?x . "[]{%l}")
            (?X . "{%l}")))
    (setq reftex-default-bibliography '("~/Dropbox/bibliography/references.bib"))
    (setq reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource"))
    (setq reftex-extra-bindings t)
    :config
    (add-hook 'LaTeX-mode-hook #'turn-on-reftex))
#+END_SRC

** Latex math
   Cdlatex lets me write latex in org-mode. It's particularly useful for math. [[https://www.gnu.org/software/emacs/manual/html_node/org/CDLaTeX-mode.html][doc]]

   #+BEGIN_SRC emacs-lisp
     (use-package cdlatex
       :ensure t
       :diminish org-cdlatex-mode
       :config
       (progn
         (add-hook 'org-mode-hook 'org-cdlatex-mode)))
   #+END_SRC

* Polymode (for knitr)
  Polymode is a (relatively new) way of working with multiple major modes. This is especially helpful if we want to use latex or markdown together with R code.

  #+BEGIN_SRC emacs-lisp
    (use-package polymode 
      :ensure t
      :mode
      ("\\.Snw" . poly-noweb+r-mode)
      ("\\.Rnw" . poly-noweb+r-mode)
      ("\\.[rR]md" . Rmd-mode)
      :init
      (progn
        (defun Rmd-mode ()
          "ESS Markdown mode for Rmd files"
          (interactive)
          (require 'poly-R)
          (require 'poly-markdown)
          (R-mode)
          (poly-markdown+r-mode))))
  #+END_SRC

* Spell Check
Flyspell checks for spelling on the fly. I use aspell instead of ispell because it's better. :-) You may need to install it separately, though I didn't need to. If you want to use non-english words, you can tell it so with ~ispell-local-dictionary~ variable. 

  #+BEGIN_SRC emacs-lisp
    (use-package flyspell
      :ensure t
      :diminish flyspell-mode
      :config
      (setq ispell-program-name "aspell")
      (setq ispell-list-command "--list")
      (add-hook 'text-mode-hook 'turn-on-flyspell)
      (add-hook 'prog-mode-hook 'flyspell-prog-mode)
      (add-hook 'ess-mode-hook 'flyspell-prog-mode))
  #+END_SRC
* Version control
  #+BEGIN_SRC emacs-lisp
    (setq vc-make-backup-files t)
  #+END_SRC
** Diff highlights 

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter+
    :ensure t
    :init
    (global-git-gutter+-mode)
    :config
    (setq git-gutter+-modified-sign "¤"))
#+END_SRC

** Git & Magit
Magit is better than the command line for git. I don't modify much. I just bind it to =C-x g=. I also set it up that it will run alone in the frame, then restore your previous window configuration when you exit.

   #+BEGIN_SRC emacs-lisp
     (use-package magit ; for git
       :ensure t
       :pin melpa-stable
       :bind
       ("C-x g" . magit-status)
       :config
       (setq magit-push-always-verify nil)
       (setq magit-diff-refine-hunk 'all) ; get highlighted word diffs
       (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
   #+END_SRC

Modes for git files:

#+BEGIN_SRC emacs-lisp
  (use-package gitattributes-mode
    :defer t
    :ensure t)
  (use-package gitconfig-mode
    :defer t
    :ensure t)
  (use-package gitignore-mode
    :defer t
    :ensure t)
#+END_SRC

And to step through the history of a file:

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t
    :commands (git-timemachine))
#+END_SRC

I autocommit a few files, like notes and todo:

#+BEGIN_SRC emacs-lisp
  (use-package git-auto-commit-mode
    :ensure t )
#+END_SRC


*** Github

**** Gists
#+BEGIN_SRC emacs-lisp
  (use-package gist
    :ensure t
    :commands (gist-list))
#+END_SRC

**** Github clone
#+BEGIN_SRC emacs-lisp
  (use-package github-clone
    :ensure t
    :commands (github-clone github-clone-fork-remote))
#+END_SRC

**** Github pull requests
#+BEGIN_SRC emacs-lisp
  (use-package magit-gh-pulls
    :ensure t
    :after magit
    :bind
    (:map magit-mode-map
          ("#" . my/load-pull-requests))
    :init
    (defun my/load-pull-requests ()
      "Starts magit-gh-pulls."
      (interactive)
      (magit-gh-pulls-mode)
      (magit-gh-pulls-popup)))
#+END_SRC

#+RESULTS:

* Webpage editing
** HTML and friends
   Web-mode takes care of a lot of html annoyances: 

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :mode 
       ("\\.html?\\'" . web-mode)
       ("\\.scss?\\'" . web-mode)
       ("\\.erb\\'" . web-mode)
       ("\\.djhtml\\'" . web-mode)
       :config
       (setq web-mode-engines-alist
             '(("django" . "\\.djhtml'"))))
   #+END_SRC

** CSS, SCSS
   And CSS/SCSS is handled nicely by this package: 

   #+BEGIN_SRC emacs-lisp
     (use-package scss-mode
       :ensure t
       :mode
       ("\\.css\\'". css-mode)
       ("\\.scss\\'" . scss-mode))
   #+END_SRC
* Email
** mu4e setup files
   I use ~mu4e~ with mbsync and mu for my email. In order to use this file, you'll need to make sure that mbsync and mu are installed on your system. mbsync requires a bit of configuration to get it started.
** mu4e setup
   Finally, we can get mu4e set up.
   #+BEGIN_SRC emacs-lisp
     (use-package mu4e
       :if (executable-find "mu")
       :bind
       (("<f1>" . my-mu4e-start)
        ("C-x m" . mu4e-compose-new)
        ("<f9>" . my/work-inbox)
        ("<f10>" . my/personal-inbox)
        :map mu4e-headers-mode-map
        ("d" . mu4e-headers-mark-for-delete)
        ("q" . mu4e-quit-session)
        :map mu4e-view-mode-map
        ("d" . mu4e-view-mark-for-delete)
        ("q" . mu4e-quit-session)
        :map mu4e-main-mode-map
        ("q" . mu4e-quit-session))
       :init
       (setq mu4e-maildir "~/.mail")
       ;; Start mu4e in fullscreen
       (defun my-mu4e-start ()
         (interactive)
         (window-configuration-to-register :mu4e-fullscreen)
         (mu4e)
         (delete-other-windows))
       ;; Restore previous window configuration
       (defun mu4e-quit-session ()
         "Restores the previous window configuration and kills the mu4e buffer"
         (interactive)
         (kill-buffer)
         (jump-to-register :mu4e-fullscreen))
       (add-hook 'after-init-hook
                 (lambda () (mu4e t))) ; starts mu4e silently when emacs starts
       (defun my/work-inbox ()
         "Jump to work email"
         (window-configuration-to-register :mu4e-fullscreen)
         (interactive)
         (mu4e~headers-jump-to-maildir "/utexas/INBOX")
         (delete-other-windows))
       (defun my/personal-inbox ()
         "Jump to work email"
         (interactive)
         (window-configuration-to-register :mu4e-fullscreen)
         (mu4e~headers-jump-to-maildir "/gmail/INBOX")
         (delete-other-windows))
       :config
       (setq send-mail-function 'smtpmail-send-it)
       (setq message-send-mail-ggfunction 'smtpmail-send-it)
       (setq smtpmail-stream-type 'starttls)
       (setq mu4e-contexts
             `( ,(make-mu4e-context
                  :name "utexas"
                  :enter-func (lambda () (mu4e-message "Switch to utexas context"))
                  ;; leave-func not defined
                  :match-func (lambda (msg)
                                (when msg
                                  (mu4e-message-contact-field-matches msg
                                                                      :to "branham@utexas.edu")))
                  :vars '((mu4e-drafts-folder           . "/utexas/[Gmail]/.Drafts")
                          (mu4e-sent-folder             . "/utexas/[Gmail]/.Sent Mail")
                          (mu4e-trash-folder            . "/utexas/[Gmail]/.Trash")
                          (user-mail-address            . "branham@utexas.edu")
                          (user-full-name               . "Alex Branham")
                          (smtpmail-smtp-user           . "branham@utexas.edu")
                          (smtpmail-default-smtp-server . "smtp.gmail.com")
                          (smtpmail-smtp-server         . "smtp.gmail.com")
                          (smtpmail-smtp-service        . 587)
                          (mu4e-compose-signature       . (concat
                                                           "J. Alexander Branham\n"
                                                           "PhD Candidate\n"
                                                           "Department of Government\n"
                                                           "University of Texas at Austin\n"
                                                           "https://www.jabranham.com"
                                                           "\n"))))
                ,(make-mu4e-context
                  :name "gmail"
                  :enter-func (lambda () (mu4e-message "Switch to gmail context"))
                  ;; leave-func not defined
                  :match-func (lambda (msg)
                                (when msg
                                  (mu4e-message-contact-field-matches msg
                                                                      :to "alex.branham@gmail.com")))
                  :vars '((user-mail-address            . "alex.branham@gmail.com")
                          (user-full-name               . "Alex Branham")
                          (smtpmail-smtp-user           . "alex.branham@gmail.com")
                          (smtpmail-default-smtp-server . "smtp.gmail.com")
                          (smtpmail-smtp-server         . "smtp.gmail.com")
                          (smtpmail-smtp-service        . 587)
                          (mu4e-compose-signature       . "")
                          (mu4e-drafts-folder           . "/gmail/[Gmail]/.Drafts")
                          (mu4e-sent-folder             . "/gmail/[Gmail]/.Sent Mail")
                          (mu4e-trash-folder            . "/gmail/[Gmail]/.Trash")))))
       (setq mu4e-context-policy 'pick-first)
       (setq mu4e-maildir-shortcuts '( ("/utexas/INBOX"  . ?u)
                                       ("/utexas/[Gmail]/.Sent Mail"   . ?s)
                                       ("/utexas/[Gmail]/.All Mail" . ?a)
                                       ("/gmail/INBOX" . ?g)))
       ;; don't ask me to quit, just quit
       (setq mu4e-confirm-quit nil)
       (setq mail-user-agent 'mu4e-user-agent)
       ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
       (setq mu4e-sent-messages-behavior 'delete)
       (setq mu4e-get-mail-command "mbsync -a"   ;; or fetchmail, or ...
             mu4e-update-interval 60)             ;; update every minute
       (setq mu4e-change-filenames-when-moving t)
       ;; setup some handy shortcuts
       ;; you can quickly switch to your Inbox -- press ``ji''
       ;; then, when you want archive some messages, move them to
       ;; the 'All Mail' folder by pressing ``ma''.
       ;; something about ourselves
       (setq mu4e-user-mail-address-list '("branham@utexas.edu" "alex.branham@gmail.com"))
       (setq mu4e-compose-dont-reply-to-self t) ; don't reply to self
       (setq mu4e-compose-complete-only-after "2015-01-01")
       (setq mu4e-view-show-addresses t)
       (setq mu4e-hide-index-messages t)
       (setq mu4e-view-show-images t)
       ;; use imagemagick, if available
       (when (fboundp 'imagemagick-register-types)
         (imagemagick-register-types))
       (setq message-kill-buffer-on-exit t)
       (setq mu4e-use-fancy-chars t)
       (setq mu4e-headers-skip-duplicates t)
       (setq mu4e-attachment-dir "~/Downloads")
       (setq mu4e-completing-read-function 'completing-read)
       (add-hook 'mu4e-view-mode-hook #'visual-line-mode)
       ;; turn off autofill mode in mu4e compose
       (defun autofill-off-visual-on ()
         "Turn off auto-fill-mode and turn on visual-mode"
         (auto-fill-mode -1)
         (visual-line-mode))
       (add-hook 'mu4e-compose-mode-hook #'autofill-off-visual-on)
       ;; use aV to open message in browser
       (add-to-list 'mu4e-view-actions
                    '("ViewInBrowser" . mu4e-action-view-in-browser) t)
       (use-package gnus-dired
         ;; make the `gnus-dired-mail-buffers' function also work on
         ;; message-mode derived modes, such as mu4e-compose-mode
         :config
         (defun gnus-dired-mail-buffers ()
           "Return a list of active message buffers."
           (let (buffers)
             (save-current-buffer
               (dolist (buffer (buffer-list t))
                 (set-buffer buffer)
                 (when (and (derived-mode-p 'message-mode)
                            (null message-sent-message-via))
                   (push (buffer-name buffer) buffers))))
             (nreverse buffers)))
         (setq gnus-dired-mail-mode 'mu4e-user-agent)
         (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode))
       ;; configure orgmode support in mu4e
       (use-package org-mu4e
         ;; when mail is sent, automatically convert org body to HTML
         :config
         (setq org-mu4e-convert-to-html t))
       (use-package mu4e-contrib
         :config
         ;; Use eww to render HTML messages: 
         (setq mu4e-html2text-command 'mu4e-shr2text)
         (add-hook 'mu4e-view-mode-hook
                   (lambda ()
                     ;; try to emulate some of the eww key-bindings
                     (local-set-key (kbd "<tab>") 'shr-next-link)
                     (local-set-key (kbd "<backtab>") 'shr-previous-link)))
         )
       (use-package mu4e-maildirs-extension
         :ensure t
         :config
         (setq mu4e-maildirs-extension-custom-list
               '("/utexas/INBOX"
                 "/gmail/INBOX"))
         (mu4e-maildirs-extension-load))
       ) ; finishes use-package mu4e
   #+END_SRC

** Helper for yasnippet

   This function helps with an expandable snippet. [[http://pragmaticemacs.com/emacs/email-templates-in-mu4e-with-yasnippet/][link]]


   #+BEGIN_SRC emacs-lisp
     ;; function to return first name of email recipients
     ;; used by yasnippet
     ;; inspired by
     ;;http://blog.binchen.org/posts/how-to-use-yasnippets-to-produce-email-templates-in-emacs.html
     (defun bjm/mu4e-get-names-for-yasnippet ()
       "Return comma separated string of names for an email"
       (interactive)
       (let ((email-name "") str email-string email-list email-name2 tmpname)
         (save-excursion
           (goto-char (point-min))
           ;; first line in email could be some hidden line containing NO to field
           (setq str (buffer-substring-no-properties (point-min) (point-max))))
         ;; take name from TO field - match series of names
         (when (string-match "^To: \"?\\(.+\\)" str)
           (setq email-string (match-string 1 str)))
         ;;split to list by comma
         (setq email-list (split-string email-string " *, *"))
         ;;loop over emails
         (dolist (tmpstr email-list)
           ;;get first word of email string
           (setq tmpname (car (split-string tmpstr " ")))
           ;;remove whitespace or ""
           (setq tmpname (replace-regexp-in-string "[ \"]" "" tmpname))
           ;;join to string
           (setq email-name
                 (concat email-name ", " tmpname)))
         ;;remove initial comma
         (setq email-name (replace-regexp-in-string "^, " "" email-name))

         ;;see if we want to use the name in the FROM field
         ;;get name in FROM field if available, but only if there is only
         ;;one name in TO field
         (if (< (length email-list) 2)
             (when (string-match "^\\([^ ,\n]+\\).+writes:$" str)
               (progn (setq email-name2 (match-string 1 str))
                      ;;prefer name in FROM field if TO field has "@"
                      (when (string-match "@" email-name)
                        (setq email-name email-name2))
                      )))
         email-name))
   #+END_SRC

** Sending mail
   #+BEGIN_SRC emacs-lisp
     (use-package smtpmail
       :if (executable-find "mu")
       :config
       ;; warn if no attachments
     (defun mbork/message-attachment-present-p ()
       "Return t if an attachment is found in the current message."
       (save-excursion
         (save-restriction
           (widen)
           (goto-char (point-min))
           (when (search-forward "<#part" nil t) t))))

     (defcustom mbork/message-attachment-intent-re
       (regexp-opt '("I attach"
                     "I have attached"
                     "I've attached"
                     "I have included"
                     "I've included"
                     "see the attached"
                     "see the attachment"
                     "attached file"))
       "A regex which - if found in the message, and if there is no
     attachment - should launch the no-attachment warning.")

     (defcustom mbork/message-attachment-reminder
       "Are you sure you want to send this message without any attachment? "
       "The default question asked when trying to send a message
     containing `mbork/message-attachment-intent-re' without an
     actual attachment.")

     (defun mbork/message-warn-if-no-attachments ()
       "Ask the user if s?he wants to send the message even though
     there are no attachments."
       (when (and (save-excursion
                    (save-restriction
                      (widen)
                      (goto-char (point-min))
                      (re-search-forward mbork/message-attachment-intent-re nil t)))
                  (not (mbork/message-attachment-present-p)))
         (unless (y-or-n-p mbork/message-attachment-reminder)
           (keyboard-quit))))

     (add-hook 'message-send-hook #'mbork/message-warn-if-no-attachments))
#+END_SRC 

** Mail alerts 
#+BEGIN_SRC emacs-lisp
  (use-package mu4e-alert
    :ensure t
    :config
    (mu4e-alert-set-default-style 'libnotify)
    (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
    (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
    (setq mu4e-alert-interesting-mail-query
          (concat
           "flag:unread"
           " AND "
           " maildir:\"/utexas/INBOX\""
           " OR maildir:\"/gmail/INBOX\""
           " AND flag:unread")))
   #+END_SRC

** Helm and emails (helm-mu)
I can use helm to help me search emails and contacts:

#+BEGIN_SRC emacs-lisp
  (use-package helm-mu
    :ensure t
    :bind
    (("M-s m" . helm-mu)
     ("M-s c" . helm-mu-contacts)
     :map mu4e-main-mode-map
     ("s" . helm-mu)
     :map mu4e-headers-mode-map
     ("s" . helm-mu)
     :map mu4e-view-mode-map
     ("s" . helm-mu)))
#+END_SRC
* Feed reader

I use [[https://github.com/skeeto/elfeed][elfeed]] to manage some RSS links:

#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure t
    :bind
    (("<f7>" . bjm/elfeed-load-db-and-open)
     :map elfeed-search-mode-map
     ("q" . bjm/elfeed-save-db-and-bury))
    :init
    ;; thanks - http://pragmaticemacs.com/emacs/read-your-rss-feeds-in-emacs-with-elfeed/
    ;; though slightly modified
    ;; functions to support syncing .elfeed between machines
    ;; makes sure elfeed reads index from disk before launching
    (defun bjm/elfeed-load-db-and-open ()
      "Load the elfeed db from disk before opening."
      (interactive)
      (elfeed-db-load)
      (elfeed)
      (elfeed-search-update--force)
      (elfeed-update))
    ;;write to disk when quiting
    (defun bjm/elfeed-save-db-and-bury ()
      "Wrapper to save the elfeed db to disk before burying buffer"
      (interactive)
      (elfeed-db-save)
      (quit-window))
    :config
    (setq elfeed-db-directory "~/Dropbox/.elfeed")
    (setq-default elfeed-search-filter "@1-week-ago +unread ")

    ;; This lets me get the http links to entries with org-capture
    ;; easily.
    (defun elfeed-entry-as-html-link ()
      "Store an http link to an elfeed entry"
      (when (equal major-mode 'elfeed-show-mode)
        (let ((description (elfeed-entry-title elfeed-show-entry))
              (link (elfeed-entry-link elfeed-show-entry)))
          (org-store-link-props
           :type "http"
           :link link
           :description description))))
    (org-link-set-parameters "elfeed" :follow #'browse-url :store #'elfeed-entry-as-html-link))
#+END_SRC

[[https://github.com/remyhonig/elfeed-org][elfeed-org]] lets me store my subscriptions in a more sane way:

#+BEGIN_SRC emacs-lisp
  (use-package elfeed-org
    :ensure t
    :config
    (elfeed-org))
#+END_SRC
* Stack Exchange 
Stack Exchange is the place to go to get questions answered. This lets me search it from within Emacs. It also sets it up to use =sx.el= to open stack exchange links (instead of eww or firefox):

#+BEGIN_SRC emacs-lisp
  (use-package sx
    :ensure t
    :bind ("M-s x" . sx-search)
    :commands (sx-search sx-open-link)
    :init
    (push '(".*stackexchange.*" . sx-open-link) browse-url-browser-function)
    (push '(".*stackoverflow.*" . sx-open-link) browse-url-browser-function))
#+END_SRC

* Ledger
[[http://ledger-cli.org/][Ledger]] is a program that I use to keep track of finances. Emacs, of course, can handle it quite nicely. 
#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :ensure t
    :if (executable-find "ledger")
    :mode ("\\.ledger$" . ledger-mode)
    :config
    (setq ledger-post-amount-alignment-column 70)
    (setq ledger-post-amount-alignment-at :decimal)
    (setq ledger-reports '(("on-hand" "ledger -f finances.ledger bal \"(Checking|Liabilities)\"")
                           ("bal" "ledger -f %(ledger-file) bal")
                           ("reg" "ledger -f %(ledger-file) reg")
                           ("payee" "ledger -f %(ledger-file) reg @%(payee)")
                           ("account" "ledger -f %(ledger-file) reg %(account)"))))
#+END_SRC
