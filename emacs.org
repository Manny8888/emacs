#+author: J. Alexander Branham
#+STARTUP: indent
#+title: Emacs settings

* Behavior 
  Change some of emacs's defaults because they suck:
  #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-message t ; disable start screen
          font-lock-maximum-decoration t) ; lots of color
  #+END_SRC

  I use ~desktop-clear~ to get rid of buffers and other things every now and then. Let's bind it to f12:

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "<f12>") #'desktop-clear)
  #+END_SRC

  C-x C-c is originally bound to kill emacs. I accidentally type this from time to time which is super-frustrating. Get rid of it:

  #+BEGIN_SRC emacs-lisp
    (global-unset-key (kbd "C-x C-c"))
  #+END_SRC
  
  In my world, =C-z= is undo, not minimize emacs:

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-z") #'undo)
  #+END_SRC

    I don't work much with emacs-lisp, so the scratch buffer shouldn't be in emacs-lisp mode:

    #+BEGIN_SRC emacs-lisp
      (setq initial-major-mode #'org-mode
            initial-scratch-message "# This buffer is for notes you don't want to save\n\n")
    #+END_SRC

    Ignore file case when trying to find stuff:

    #+BEGIN_SRC emacs-lisp
      (setq read-file-name-completion-ignore-case t)
    #+END_SRC

    Write customization elsewhere, don't load it.

    #+BEGIN_SRC emacs-lisp
      (setq custom-file (concat user-emacs-directory "customize.el"))
    #+END_SRC

    Delete my files by moving them to the trash. I'm human and occasionally delete things that I actually want later:

    #+BEGIN_SRC emacs-lisp
      (setq delete-by-moving-to-trash t)
    #+END_SRC

** UTF-8
   Pretty please use utf-8 for all the things:

   #+BEGIN_SRC emacs-lisp
     (set-language-environment "UTF-8")
     (prefer-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-buffer-file-coding-system 'utf-8)
     (set-default-coding-systems 'utf-8)
   #+END_SRC
** Theme
   By default, emacs starts with a blindingly white theme. Let's get rid of that pronto.
   #+BEGIN_SRC emacs-lisp
     (use-package spacemacs-theme
       :ensure t
       :defer t
       :init
       (load-theme 'spacemacs-dark t))
   #+END_SRC

** Scrolling
   Emacs has some awful scrolling by default. This gets rid of that. 

   #+BEGIN_SRC emacs-lisp
     (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ; one line at a time
     (setq mouse-wheel-progressive-speed nil) ; don't accelerate scrolling
     (setq mouse-wheel-follow-mouse 't) ; scroll window under mouse
     (setq scroll-step 1) ; keyboard scroll one line at a time
     (setq view-read-only t) ; open read only buffers in view-mode
     ;; the defaults C-v and M-v scroll a full page, which is too much.
     ;; rebind to a half page:
     (use-package view
       :bind
       ("C-v" . View-scroll-half-page-forward)
       ("M-v" . View-scroll-half-page-backward))
   #+END_SRC

** Smart parens
   I'm not good at keeping track of parentheses. This makes me slightly better at it. It also keeps track of other things that should "match" like {}, [], "", ``'' (in latex mode), etc.

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens-config
       :ensure smartparens
       :diminish smartparens-mode
       :commands (smartparens-global-strict-mode)
       :bind
       ("C-M-a" . sp-beginning-of-sexp)
       ("C-M-e" . sp-end-of-sexp)
       ("M-]" . sp-unwrap-sexp) ; C-M-SPC is bound to mark-sexp
       :init
       (smartparens-global-strict-mode)
       (show-smartparens-global-mode))
   #+END_SRC

** PDF viewer
   I like emacs, so why not view PDFs in it? Build the server when it asks - this may take a second.

   NOTE: ~pdf-tools~ only officially supports gnu/linux operating systems. I think that it will work on macs as well, but you may have to finagle it a bit. Regardless, I tell emacs to only use it if the OS is linux based.

   #+BEGIN_SRC emacs-lisp 
     (when (eq system-type 'gnu/linux)
       (use-package pdf-tools
         :ensure t
         :config
         (pdf-tools-install)
         (setq TeX-view-program-selection '((output-pdf "pdf-tools")))
         (setq TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))))
   #+END_SRC

** File finder (Dired)
   Emacs can act as your file finder/explorer. Dired is the built-in way to do this.

   #+BEGIN_SRC emacs-lisp
     (setq dired-auto-revert-buffer t)
     (setq dired-dwim-target t)
     (setq dired-recursive-copies (quote always))
     (setq dired-recursive-deletes (quote always))
     ;; Hide details (owner, permissions) in dired
     (add-hook 'dired-mode-hook
               (lambda () (dired-hide-details-mode 1)))
   #+END_SRC

   Here I sort dired buffers with directories (folders) first, then everything else:

   #+BEGIN_SRC emacs-lisp
     (defadvice dired-readin (after dired-after-updating-hook first () activate)
       "Sort dired listings with directories first before adding marks."
       (save-excursion
         (let (buffer-read-only)
           (forward-line 2) ;; beyond dir. header
           (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
         (set-buffer-modified-p nil)))
   #+END_SRC

   This lets me make directories on the fly similar to =mkdir -p=. [[http://mbork.pl/2016-07-25_Making_directories_on_the_fly][Thanks!]]

   #+BEGIN_SRC emacs-lisp
     (defun make-parent-directory ()
       "Make sure the directory of `buffer-file-name' exists."
       (make-directory (file-name-directory buffer-file-name) t))

     (add-hook 'find-file-not-found-functions #'make-parent-directory)
   #+END_SRC
** Modeline
   The default modeline is nice enough, but this one is much better looking:

   #+BEGIN_SRC emacs-lisp
     (use-package spaceline-config
       :ensure spaceline
       :config
       (spaceline-emacs-theme)
       (spaceline-toggle-buffer-encoding-abbrev-off))
   #+END_SRC
** Which-key
   [[https://github.com/justbur/emacs-which-key][Which key]] shows key bindings for incomplete commands (prefixes).

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :ensure t
       :diminish which-key-mode
       :defer 10
       :config
       (which-key-mode))
   #+END_SRC

** Window switching 
I can use =ace-window= to quickly jump from window to window

   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :ensure t
       :bind ; overrides some useless face font locking
       ("M-o" . ace-window))
   #+END_SRC

** Keyfreq
   This is a neat package that keeps track of which commands you're using. You can then assign your most-used commands to more accessible keybindings.
   #+BEGIN_SRC emacs-lisp
     (use-package keyfreq
       :ensure t
       :config
       (setq keyfreq-excluded-commands
             '(self-insert-command
               org-self-insert-command
               delete-backward-char
               pdf-view-next-page-command
               yas-expand
               pdf-view-scroll-up-or-next-page
               org-delete-backward-char
               mouse-drag-region
               LaTeX-insert-left-brace
               mouse-drag-region
               newline
               abort-recursive-edit
               previous-line
               next-line))
       (keyfreq-mode 1)
       (keyfreq-autosave-mode 1))
   #+END_SRC

** Server
   Start the server:
   #+BEGIN_SRC emacs-lisp
     (use-package server
       :if window-system
       :config
       (unless (server-running-p)
         (add-hook 'after-init-hook #'server-start t)))
   #+END_SRC
** Crux
   [[https://github.com/bbatsov/crux/blob/master/crux.el][Crux]] is a collection of useful extensions. Here I bind some of the more useful functions:

   #+BEGIN_SRC emacs-lisp
     (use-package crux
       :ensure t
       :diminish abbrev-mode
       :bind
       (("C-x i" . crux-ispell-word-then-abbrev)
        ("C-c e" . crux-sudo-edit)
        :map prog-mode-map
        ("C-a" . crux-move-beginning-of-line))
       :config
       (setq save-abbrevs 'silently)
       (setq-default abbrev-mode t))
   #+END_SRC

** Avy
   Avy lets me jump anywhere on the screen super quickly. Just =M-S=, then one letter to jump to wherever you want:
   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :ensure t
       :bind
       ("C-M-g" . avy-goto-word-1))
   #+END_SRC

** Help windows
   You can use =C-h f=, =C-h v= and others to read docs for functions, variables, etc. This makes emacs switch focus to these windows:

   #+BEGIN_SRC emacs-lisp
     (setq help-window-select t)
   #+END_SRC
** popwin
   [[https://github.com/m2ym/popwin-el][popwin]] describes itself as freeing me from the hell of annoying buffers. Let's see if that's true:

   #+BEGIN_SRC emacs-lisp
     (use-package popwin
       :ensure t
       :config
       (popwin-mode 1))
   #+END_SRC

** Passwords
   I use [[https://www.passwordstore.org/][pass]] to manage all my passwords and login info. This lets me easily access it from within emacs:

   #+BEGIN_SRC emacs-lisp
     (when (executable-find "pass")
       (use-package password-store
         :ensure t
         :commands (password-store-copy password-store-edit)
         :config
         (setq password-store-password-length 20)))
   #+END_SRC
** Try
   This package lets me try out other packages before installing them by installing them to tmp:


   #+BEGIN_SRC emacs-lisp
     (use-package try
       :ensure t
       :commands (try))
   #+END_SRC

** Undo-tree
   Emacs undo system is incredibly powerful but a bit confusing. This package has a great visualization system that helps out, bound to =C-x u= by default. Originally, =C-z= minimizes emacs. That's stupid, so let's make it undo instead like a sane person. Note that redo is bound

   I've turned this off, as I'm experiencing a weird bug and trying to find the cause!

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :ensure t
       :diminish undo-tree-mode
       :init
       (global-undo-tree-mode))
   #+END_SRC

** Zooming
   Using this hydra, I can press =f2= and then =g= or =l= to zoom in/out

   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :ensure t
       :config
       (defhydra hydra-zoom ()
         "zoom"
         ("g" text-scale-increase "in")
         ("l" text-scale-decrease "out"))
       (global-set-key (kbd "<f2>") 'hydra-zoom/body))
   #+END_SRC

** Move buffers
   Sometimes the buffers are in the wrong places. This lets me move them around.

   #+BEGIN_SRC emacs-lisp
     (use-package buffer-move
       :ensure t
       :bind
       ("M-S-<up>" . buf-move-up)
       ("M-S-<down>" . buf-move-down)
       ("M-S-<left>" . buf-move-left)
       ("M-S-<right>" . buf-move-right)
       :config
       (setq buffer-move-behavior 'move))
   #+END_SRC

   Here's a quick [[https://github.com/abo-abo/hydra][hydra]] that I wrote to quickly move buffers from window to window:

   #+BEGIN_SRC emacs-lisp
     (defhydra hydra-window ()
       "window management"
       ("l" buf-move-left "left")
       ("r" buf-move-right "right")
       ("d" buf-move-down "down")
       ("u" buf-move-up "up"))
     (global-set-key (kbd "C-c m b") 'hydra-window/body)
   #+END_SRC

** Auto indent

   [[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent mode]] keeps code indented automatically, even after rearranging stuff:

   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent
       :ensure t
       :config
       (global-aggressive-indent-mode)
       (add-to-list 'aggressive-indent-excluded-modes 'inferior-ess-mode))
   #+END_SRC

** System packages
   This is a collection of functions I wrote to help me manage installed system packages with emacs. You can find the package [[https://github.com/jabranham/system-packages][on github]]

   #+BEGIN_SRC emacs-lisp
     (use-package system-packages
       :load-path "~/code/system-packages"
       :bind ("<f5>" . hydra/system-packages/body) 
       :config
       (defhydra hydra/system-packages ()
         "Manage system packages"
         ("i" system-packages-install "install")
         ("s" system-packages-search "search")
         ("U" system-packages-uninstall "uninstall")
         ("u" system-packages-update "update")
         ("l" system-packages-list-installed-packages "list installed")
         ("O" system-packages-remove-orphaned "remove orphans")))
   #+END_SRC

** Multiple cursors 
   Emacs can support multiple cursors. I don't use this much, but it's super handy when I do need it:
   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :bind
       ("C-c m c l" . mc/edit-lines)
       ("C-c m c a" . mc/mark-all-like-this))
   #+END_SRC
** Browser
Use Emacs' built in =eww= broswer by default. If a webpage requires more, I can switch to the system default by tapping =&=:

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function
        '((".*login.utexas.*" . browse-url-firefox)
          (".*utdirect.*utexas.*" . browse-url-firefox)
          (".*github.*" . browse-url-firefox)
          (".*youtube.*" . browse-url-firefox)
          (".*youtu.be*" . browse-url-firefox)
          ("." . eww-browse-url)))
#+END_SRC

By default, =M-s M-w= searches for text in the region. I change it to search for text in region if active, prompt otherwise:
#+BEGIN_SRC emacs-lisp
  (defun jab/eww-search (orig-fun &rest args)
    (if (region-active-p) (apply orig-fun args)
      (eww (read-string "Query: "))))
  (advice-add 'eww-search-words :around #'jab/eww-search)
#+END_SRC

** Miscellaneous 
   Here are a bunch of things I want emacs to do (or not) but don't seem to fit in other sections.

   For when I need lots of text: 
   #+BEGIN_SRC emacs-lisp
     (defun lorem ()
       "Insert a lorem ipsum."
       (interactive)
       (insert "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do "
               "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim"
               "ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut "
               "aliquip ex ea commodo consequat. Duis aute irure dolor in "
               "reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla "
               "pariatur. Excepteur sint occaecat cupidatat non proident, sunt in "
               "culpa qui officia deserunt mollit anim id est laborum."))
   #+END_SRC

Rebind =M-;= to =comment-line= (from =comment-dwim=):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-;") #'comment-line)
#+END_SRC
*** Prettify symbols
Prettify-symbols-mode will replace some symbols (like "lambda") with their prettier cousins (like \lambda). 

#+BEGIN_SRC emacs-lisp
  (setq prettify-symbols-unprettify-at-point 'right-edge)
  (global-prettify-symbols-mode)
#+END_SRC

*** Replace selected text
    Emacs by default doesn't replace selected text if you start typing over it. Since that's the behavior of virtually all other programs, let's make emacs do that too:

    #+BEGIN_SRC emacs-lisp
      (delete-selection-mode)
    #+END_SRC

*** Backup files
    I want emacs to make these, but don't want to clutter up my project folders with tons of backup files. Solution: put them in the ~.emacs.d/~ directory.
    #+BEGIN_SRC emacs-lisp
      (setq backup-directory-alist
            `(("." . ,(expand-file-name
                       (concat user-emacs-directory "backups")))))
    #+END_SRC
*** Blinking cursor & highlight line
    A blinking cursor gets kinda annoying, so get rid of it:

    #+BEGIN_SRC emacs-lisp
      (blink-cursor-mode -1)
    #+END_SRC

    Also, I like the current line to be highlighted. Makes it easy to see where I am:

    #+BEGIN_SRC emacs-lisp
      (global-hl-line-mode)
    #+END_SRC
*** Refresh buffers
    Emacs should refresh buffers automatically so if they've changed on disk the buffer will update. I want dired to do this, but don't ask me.

    #+BEGIN_SRC emacs-lisp
      (setq global-auto-revert-non-file-buffers t)
      (setq auto-revert-verbose nil)
      (global-auto-revert-mode 1)
    #+END_SRC

*** Resize windows
    We can resize windows now! 
     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
       (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
       (global-set-key (kbd "S-C-<down>") 'shrink-window)
       (global-set-key (kbd "S-C-<up>") 'enlarge-window)
     #+END_SRC
*** Move around quickly
    You can ~C-n~ and whatnot to go by line, but sometimes I want to move a bit more quickly than that. Using ~C-S-n~ will now let me:

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-S-n")
                      (lambda ()
                        (interactive)
                        (ignore-errors (next-line 5))))

      (global-set-key (kbd "C-S-p")
                      (lambda ()
                        (interactive)
                        (ignore-errors (previous-line 5))))

      (global-set-key (kbd "C-S-f")
                      (lambda ()
                        (interactive)
                        (ignore-errors (forward-char 5))))

      (global-set-key (kbd "C-S-b")
                      (lambda ()
                        (interactive)
                        (ignore-errors (backward-char 5))))
    #+END_SRC

*** Start maximized
    #+BEGIN_SRC emacs-lisp
      (add-hook 'after-init-hook (lambda () (toggle-frame-maximized)))
    #+END_SRC

*** Better defaults 
    This is inspired by the [[https://github.com/technomancy/better-defaults][better defaults]] package, but I don't like everything in there.

    Yes, please save my place when opening/closing files: 

    #+BEGIN_SRC emacs-lisp
      (use-package saveplace
        :config
        (save-place-mode))
    #+END_SRC

    Get rid of menu-bar, toolbar, and the scroll bars
    #+BEGIN_SRC emacs-lisp
      (menu-bar-mode -1)
      (tool-bar-mode -1)
      (scroll-bar-mode -1)
    #+END_SRC

    Don't ever use tabs. Always use spaces. 
    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil)
    #+END_SRC

    Emacs "kills" and "yanks" instead of cutting and pasting. Using this, we can ~C-w~ and that will kill the active region (whatever you have selected). If you haven't selected anything, it'll kill the line it's on.
    #+BEGIN_SRC emacs-lisp
      ;; http://emacs-fu.blogspot.co.uk/2009/11/copying-lines-without-selecting-them.html
      (defadvice kill-region (before slick-cut activate compile)
        "When called interactively with no active region, kill a single line instead."
        (interactive
         (if mark-active (list (region-beginning) (region-end))
           (list (line-beginning-position)
                 (line-beginning-position 2)))))
    #+END_SRC

    This will set the frame name to the name of the file, so you can see what file you've got selected in the menu bar.

    #+BEGIN_SRC emacs-lisp
      (setq frame-title-format
            '("Emacs - " (buffer-file-name "%f"
                                           (dired-directory dired-directory "%b"))))
    #+END_SRC

    Because I'm lazy, I want to just type y or n instead of spelling out yes/no.

    #+BEGIN_SRC emacs-lisp
      (fset 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

    Also, don't ask me when I try to create a new file. Just create it.

    #+BEGIN_SRC emacs-lisp
      (setq confirm-nonexistent-file-or-buffer nil)
    #+END_SRC

      We can use shift-mouse for selecting from point:

      #+BEGIN_SRC emacs-lisp
        (define-key global-map (kbd "<S-down-mouse-1>") 'mouse-save-then-kill)
      #+END_SRC

    Use regex searches by default:

    #+BEGIN_SRC emacs-lisp
      (setq search-default-mode t)
    #+END_SRC

    A few final modifications: 

    #+BEGIN_SRC emacs-lisp
      (setq   save-interprogram-paste-before-kill t
              apropos-do-all t
              mouse-yank-at-point t
              require-final-newline t
              visible-bell t
              load-prefer-newer t
              ediff-window-setup-function 'ediff-setup-windows-plain
              save-place-file (concat user-emacs-directory "places"))
    #+END_SRC
* Auto completion
** Company mode
   Company mode provides autocompletion of text and code. 

   #+BEGIN_SRC emacs-lisp
     (use-package company 
       :ensure t
       :diminish company-mode
       :init
       (add-hook 'after-init-hook #'global-company-mode)
       :config
       (use-package company-statistics
         :ensure t
         :config
         (company-statistics-mode))
       (use-package company-math
         :ensure t
         :config
         (add-to-list 'company-backends 'company-math-symbols-latex))
       (use-package company-quickhelp
         :ensure t
         :config
         (company-quickhelp-mode 1))
       (use-package company-flx
         :ensure t
         :init
         (with-eval-after-load 'company
           (company-flx-mode +1)))
       (define-key company-active-map (kbd "<tab>")
         (lambda () (interactive) (company-complete-common-or-cycle 1)))
       (use-package company-web-html
         :ensure company-web)
       (use-package company-shell
         :ensure t
         :config
         (add-to-list 'company-backends 'company-shell)))
   #+END_SRC
** Yasnippet 
   Yasnippet allows you to type an abbreviation and then expand it into a template. We can look at yasnippet's documentation [[https://github.com/capitaomorte/yasnippet][on github]].

   Yasnippet by default checks for snippets in two places: a path relative to yasnippet.el (these are the default snippets that come with the package). If I want to make my own, I can put then in ~.emacs.d/snippets~ and it should find them there as well.
  
   You can use the tab key to expand a snippet once you've typed in the "key". It's pretty smart in that if tab fails for yasnippet, it then checks for whatever tab was originally bound to.

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :ensure t
       :diminish yas-minor-mode
       :config
       (add-hook 'term-mode-hook (lambda () (yas-minor-mode -1)))
       (define-key yas-minor-mode-map (kbd "C-c &") nil)
       (yas-global-mode))
   #+END_SRC
* Functions
** Jekyll functions
   I use ~jekyll-publish-draft~ to move a post from _drafts/ to _posts/ which publishes it to my blog. Inspiration from [[http://pasoev.github.io/programming/2015/10/31/jekyll-posts-emacs-capture/][here]]

   #+BEGIN_SRC emacs-lisp
     (defun today-is ()
       "Return current year-month-day."
       (format-time-string "%Y-%m-%d"))

     (defun jekyll-drafts ()
       (let ((default-directory
               (concat (projectile-project-root) "_drafts")))
         (file-expand-wildcards "*.md")))

     (defun jekyll-publish-draft (post)
       "Mark one of the posts from the Jekyll drafts directory as published.
        This actually means moving the post from the _drafts to the _posts 
        directory."
       (interactive
        (list (completing-read "Post to publish: "
                               (jekyll-drafts) nil t "")))
       (copy-file (concat (projectile-project-root) "_drafts/" post)
                  (concat (projectile-project-root) "_posts/" (today-is) "-" post))
       (delete-file (concat (projectile-project-root) "_drafts/" post)))

   #+END_SRC

** Swap horizontal and vertical windows
   Sometimes I want horizontal windows to be vertical or vice versa. This lets me make that happen:

   #+BEGIN_SRC emacs-lisp
     (defun toggle-window-split ()
       (interactive)
       (if (= (count-windows) 2)
           (let* ((this-win-buffer (window-buffer))
                  (next-win-buffer (window-buffer (next-window)))
                  (this-win-edges (window-edges (selected-window)))
                  (next-win-edges (window-edges (next-window)))
                  (this-win-2nd (not (and (<= (car this-win-edges)
                                              (car next-win-edges))
                                          (<= (cadr this-win-edges)
                                              (cadr next-win-edges)))))
                  (splitter
                   (if (= (car this-win-edges)
                          (car (window-edges (next-window))))
                       'split-window-horizontally
                     'split-window-vertically)))
             (delete-other-windows)
             (let ((first-win (selected-window)))
               (funcall splitter)
               (if this-win-2nd (other-window 1))
               (set-window-buffer (selected-window) this-win-buffer)
               (set-window-buffer (next-window) next-win-buffer)
               (select-window first-win)
               (if this-win-2nd (other-window 1))))))
   #+END_SRC
** Splitting windows
   These functions make splitting windows behave more like I want it to. This way, calling ~C-x 2~ or ~C-x 3~ both splits the window /and/ shows the last buffer.

   #+BEGIN_SRC emacs-lisp
     (defun my/vsplit-last-buffer (prefix)
       "Split the window vertically and display the previous buffer."
       (interactive "p")
       (split-window-vertically)
       (other-window 1 nil)
       (if (= prefix 1)
           (switch-to-next-buffer)))
     (defun my/hsplit-last-buffer (prefix)
       "Split the window horizontally and display the previous buffer."
       (interactive "p")
       (split-window-horizontally)
       (other-window 1 nil)
       (if (= prefix 1) (switch-to-next-buffer)))
     (bind-key "C-x 2" 'my/vsplit-last-buffer)
     (bind-key "C-x 3" 'my/hsplit-last-buffer)
   #+END_SRC
** Calc
   From [[https://www.reddit.com/r/emacs/comments/445w6s/whats_some_small_thing_in_your_dotemacs_that_you/][this reddit thread]]

   #+BEGIN_SRC emacs-lisp
     (defun my/calc-eval-region (arg)
       "Evaluate an expression in calc and communicate the result.

     If the region is active evaluate that, otherwise search backwards
     to the first whitespace character to find the beginning of the
     expression. By default, replace the expression with its value. If
     called with the universal prefix argument, keep the expression
     and insert the result into the buffer after it. If called with a
     negative prefix argument, just echo the result in the
     minibuffer."
       (interactive "p")
       (let (start end)
         (if (use-region-p)
             (setq start (region-beginning) end (region-end))
           (progn
             (setq end (point))
             (setq start (search-backward-regexp "\\s-\\|\n" 0 1))
             (setq start (1+ (if start start 0)))
             (goto-char end)))
         (let ((value (calc-eval (buffer-substring-no-properties start end))))
           (pcase arg
             (1 (delete-region start end))
             (4 (insert " = ")))
           (pcase arg
             ((or 1 4) (insert value))
             (-1 (message value))))))
   #+END_SRC
** Insert file name

This function ([[http://pragmaticemacs.com/emacs/insert-file-name/][credit]]) lets me insert a file name easily. Defaults to relative path, use the universal argument to get the absolute path.

   #+BEGIN_SRC emacs-lisp
     (defun my/insert-file-name (filename &optional args)
       "Insert name of file FILENAME into buffer after point.

       Prefixed with \\[universal-argument], expand the file name to
       its fully canocalized path.  See `expand-file-name'.

       Prefixed with \\[negative-argument], use relative path to file
       name from current directory, `default-directory'.  See
       `file-relative-name'.

       The default with no prefix is to insert the file name exactly as
       it appears in the minibuffer prompt."
       ;; Based on insert-file in Emacs -- ashawley 20080926
       (interactive "*fInsert file name: \nP")
       (cond ((eq '- args)
              (insert (expand-file-name filename)))
             ((not (null args))
              (insert (filename)))
             (t
              (insert (file-relative-name filename)))))
   #+END_SRC

** Go to this file
   It's nice to have a function to find this file quickly. Here's one:


   #+BEGIN_SRC emacs-lisp
     (defun my/find-emacs-file ()
       "Find my emacs org file"
       (interactive)
       (find-file (concat user-emacs-directory "emacs.org")))

     (global-set-key (kbd "<f11>") #'my/find-emacs-file)
   #+END_SRC
* Ivy

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :diminish ivy-mode
    :bind
    ("C-M-z" . ivy-resume)
    :config
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "")
    (setq ivy-re-builders-alist
          '((t . ivy--regex-ignore-order)))
    (ivy-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    ("M-x" . counsel-M-x)
    ("C-x C-f" . counsel-find-file)
    ("C-h f" . counsel-describe-function)
    ("C-h v" . counsel-describe-variable)
    ("M-y" . counsel-yank-pop))
#+END_SRC

** Ivy and references (ivy-bibtex)
   #+BEGIN_SRC emacs-lisp
     (use-package ivy-bibtex
       :ensure t
       :bind*
       ("C-c C-r" . ivy-bibtex)
       :init
       ;; Set up how keys should look - authoryear
       (setq bibtex-autokey-titleword-length 0
             bibtex-autokey-titleword-separator ""
             bibtex-autokey-titlewords 0
             bibtex-autokey-year-length 4
             bibtex-autokey-year-title-separator "")
       (setq bibtex-align-at-equal-sign t)
       (setq bibtex-files '("~/Dropbox/bibliography/references.bib"))
       :config
       (setq bibtex-completion-bibliography "~/Dropbox/bibliography/references.bib"
             bibtex-completion-library-path "~/Dropbox/bibliography/bibtex-pdfs"
             bibtex-completion-notes-path "~/Dropbox/bibliography/notes.org"
             bibtex-completion-notes-template-one-file
             "\n* TODO ${year} - ${title}\n  :PROPERTIES:\n  :Custom_ID: ${=key=}\n  :AUTHOR: ${author}\n  :JOURNAL: ${journal}\n  :YEAR: ${year}\n  :VOLUME: ${volume}\n  :PAGES: ${pages}\n  :DOI: ${doi}\n  :URL: ${url}\n :END:\n"
             )
       (setq bibtex-completion-cite-commands '("autocite" "textcite" "citep" "citet" "citeauthor" "citeyear" "Citep" "Citet"))
       (setq ivy-bibtex-default-action #'ivy-bibtex-insert-citation)

       ;; temporary fix so that I can bind C-c C-r globally yet still have
       ;; ivy-bibtex insert autocite: citations in org-mode
       (defun bibtex-completion-format-citation-org-autocite (keys)
         "Formatter for org autocite references."
         (s-join ", "
                 (--map (format "autocite:%s" it) keys)))
       (setq bibtex-completion-format-citation-functions
             '((org-mode . bibtex-completion-format-citation-org-autocite)
               (latex-mode . bibtex-completion-format-citation-cite)
               (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
               (default . bibtex-completion-format-citation-default)))
       )
   #+END_SRC

** Ivy and makefiles
I can setup ivy to deal with makefiles easily: 

#+BEGIN_SRC emacs-lisp
  (use-package helm-make
    :ensure t
    :bind
    ("C-c p c" . helm-make-projectile)
    :init
    (setq helm-make-completion-method 'ivy))
#+END_SRC
* Projectile 
Projectile makes using projects easier in emacs. It also plays well with ivy, so let's set that up.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :config
    (def-projectile-commander-method ?F
      "Git fetch."
      (magit-status)
      (call-interactively #'magit-fetch-current))
    (setq projectile-completion-system 'ivy)
    (projectile-global-mode)
    (define-key projectile-command-map (kbd "c") #'helm-make-projectile)
    (use-package counsel-projectile
      :ensure t
      :config
      (counsel-projectile-on)))
   #+END_SRC

* Org
  Org mode is a great thing. I use it for writing academic papers, managing my schedule, managing my references and notes, writing presentations, writing lecture slides, and pretty much anything else. This file is written in org-mode.

  Define =C-c l= to =org-store-link=: 

  #+BEGIN_SRC emacs-lisp
    (define-key global-map "\C-cl" 'org-store-link)
  #+END_SRC

** Exporting
   HTML and latex shown by default, let's add markdown:

   #+BEGIN_SRC emacs-lisp
     (use-package ox-md)
   #+END_SRC

   I use xelatexmk so that org uses xelatex by default. I really like the [[https://github.com/matze/mtheme][metropolis beamer theme.]]

   #+BEGIN_SRC emacs-lisp
     (setq org-latex-pdf-process (list "latexmk -f -shell-escape -xelatex %f"))
   #+END_SRC

   This makes org export smart quotes so that it uses ~``word``~ style quotes for latex export:

   #+BEGIN_SRC emacs-lisp
     (setq org-export-with-smart-quotes t)
   #+END_SRC

   This lets me override all the export variables with a =#+BIND:= statement at the beginning of org-mode files for export:

   #+BEGIN_SRC emacs-lisp
     (setq org-export-allow-bind-keywords t)
   #+END_SRC

   Remove =<...>= from timestamps when exporting to latex. [[http://stackoverflow.com/questions/23297422/org-mode-timestamp-format-when-exported][Thanks]]

   #+BEGIN_SRC emacs-lisp
     (defun my/org-export-filter-timestamp-remove-brackets (timestamp backend info)
       "removes relevant brackets from a timestamp"
       (cond
        ((org-export-derived-backend-p backend 'latex)
         (replace-regexp-in-string "[<>]\\|[][]" "" timestamp))
        ((org-export-derived-backend-p backend 'html)
         (replace-regexp-in-string "&[lg]t;\\|[][]" "" timestamp))))

     (eval-after-load 'ox '(add-to-list
                            'org-export-filter-timestamp-functions
                            'my/org-export-filter-timestamp-remove-brackets))
   #+END_SRC

** Code blocks (org-babel)
   Org-babel is included in org. We just need to tell it which languages to load. And don't ask us if we're sure we want to run code blocks when we ~C-c C-c~. Finally, open the code block in the current window when we use ~C-'~

   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (latex . t)
        (python . t)
        (R . t)
        (sh . t)))
     (setq org-confirm-babel-evaluate nil)
     (setq org-src-window-setup 'current-window)
   #+END_SRC

*** Code block font locking
    This will make the contents of code blocks use the same font locking (syntax highlighting) as the major mode. It'll also make the tab key act like you want it to inside code blocks.

    #+BEGIN_SRC emacs-lisp
      (setq org-src-fontify-natively     t
            org-src-tab-acts-natively    t)
    #+END_SRC

*** Adding SRC blocks
    Here I define a function ([[https://github.com/vdemeester/emacs-config/blob/master/.emacs.d/emacs.org][thanks!]]) that lets me easily add and edit source blocks in org mode:

    #+BEGIN_SRC emacs-lisp
      (defun my/org-insert-src-block (src-code-type)
        "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
        (interactive
         (let ((src-code-types
                '("emacs-lisp" "python" "sh" "calc" "R" "latex" "org")))
           (list (ido-completing-read "Source code type: " src-code-types))))
        (progn
          (newline-and-indent)
          (insert (format "#+BEGIN_SRC %s\n" src-code-type))
          (newline-and-indent)
          (insert "#+END_SRC\n")
          (previous-line 2)
          (org-edit-src-code)))

      (define-key org-mode-map (kbd "C-c s a") 'my/org-insert-src-block)
    #+END_SRC

** References (org-ref) 
   I use org-ref to manage my references. 
   #+BEGIN_SRC emacs-lisp
     (use-package org-ref 
       :ensure t
       :init
       (setq org-ref-completion-library 'org-ref-ivy-cite)
       (setq org-ref-bibliography-notes "~/Dropbox/bibliography/notes.org"
             org-ref-default-bibliography '("~/Dropbox/bibliography/references.bib")
             org-ref-pdf-directory  "~/Dropbox/bibliography/bibtex-pdfs"
             org-ref-default-citation-link "autocite")
       :config
       (defvar my/notes-template
         "* TODO %y - %t\n :PROPERTIES:\n  :Custom_ID: %k\n  :AUTHOR: %9a\n  :JOURNAL: %j\n  :YEAR: %y\n  :VOLUME: %v\n  :PAGES: %p\n  :DOI: %D\n  :URL: %U\n :END:\n")  
       (setq org-ref-note-title-format my/notes-template)
       (use-package doi-utils)
       (use-package org-ref-isbn)
       (use-package org-ref-latex))
   #+END_SRC

** Latex
   Cdlatex lets me write latex in org-mode. It's particularly useful for math. [[https://www.gnu.org/software/emacs/manual/html_node/org/CDLaTeX-mode.html][doc]]

   #+BEGIN_SRC emacs-lisp
     (use-package cdlatex
       :ensure t
       :diminish org-cdlatex-mode
       :config
       (progn
         (add-hook 'org-mode-hook 'org-cdlatex-mode)))
   #+END_SRC

   Org can preview latex fragments with =C-c C-x C-l= but it uses dvipng by default. Let's switch it to imagemagick:


   #+BEGIN_SRC emacs-lisp
     (setq org-latex-create-formula-image-program 'imagemagick)
   #+END_SRC

** Agenda 
   Here's where I set which files are added to org-agenda, which controls org's global todo list, scheduling, and agenda features. I use Dropbox to keep these files in sync across computers.

   #+BEGIN_SRC emacs-lisp
     (use-package org-agenda
       :bind
       (("C-c a" . org-aganda)
        ("C-'" . org-cycle-agenda-files))
       :init
       (setq org-directory "~/Dropbox/org/")
       ;; set up org agenda files for the agenda
       (setq org-agenda-files (list (concat org-directory "todo.org")
                                    "~/Dropbox/bibliography/notes.org"))
       ;; remove C-c [ from adding org file to front of agenda
       (add-hook 'org-mode-hook
                 (lambda ()
                   (local-unset-key (kbd "C-c ["))))
       :config
       (setq org-agenda-skip-deadline-if-done t ; remove done deadlines from agenda
             org-agenda-skip-scheduled-if-done t ; remove done scheduled from agenda
             org-deadline-warning-days 3) ; warn me 3 days before a deadline
       (setq org-agenda-window-setup 'current-window ; use current window for agenda
             ;; restore previous config after I'm done
             org-agenda-restore-windows-after-quit t) 
       )
#+END_SRC

** Capture
I use org-capture to create short notes about all kinds of things. I can capture emails to remember for later, quick thoughts for later, RSS feeds (see [[Feed reader]]), really anything. 

#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :bind
    ("C-c c" . org-capture)
    :init
    (setq org-default-notes-file (concat org-directory "todo.org")))
#+END_SRC
*** Org-eww
Org-eww lets me capture eww webpages with org-mode

#+BEGIN_SRC emacs-lisp
  (use-package org-eww)
#+END_SRC

*** Firefox
This line is necessary for the [[https://addons.mozilla.org/en-US/firefox/addon/org-mode-capture/][org-mode capture]] extension for Firefox. 

#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC

*** Capture templates

    #+BEGIN_SRC emacs-lisp
      (setq org-capture-templates
            (quote (
                    ("s" "store" entry (file+headline (concat org-directory "todo.org") "Tasks")
                     "* TODO %?\n   %a")
                    ("t" "task" entry (file+headline (concat org-directory "todo.org") "Tasks")
                     "* TODO %?")
                    ("x" "firefox" entry (file+headline (concat org-directory "todo.org") "Firefox")
                     "* TODO %c" :immediate-finish t))))
    #+END_SRC

** Refile
   Org-refile lets me quickly move around headings in org files. It plays nicely with org-capture, which I use to turn emails into TODOs easily (among other things, of course)

   #+BEGIN_SRC emacs-lisp
     (setq org-outline-path-complete-in-steps nil)
     (setq org-refile-allow-creating-parent-nodes (quote confirm))
     (setq org-refile-use-outline-path t)
     (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
   #+END_SRC

** Pomodoro
I can use =org-pomodoro= for a [[http://pomodorotechnique.com/][pomodoro]]. By default, it works in 25-minute work blocks and 5 minute breaks after. The fourth break is longer - 20 minutes by default.

I like to use system alerts, which are more visible than just sending it to Emacs's *Messages* buffer. I probably need to do this with add-to-list or something but this works for now:

#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :ensure t
    :commands (org-pomodoro)
    :config
    (setq alert-user-configuration (quote ((((:category . "org-pomodoro")) libnotify nil)))))
#+END_SRC

** org-projectile
[[https://github.com/IvanMalison/org-projectile][org-projectile]] nicely integrates org mode with projects tracked in projectile. 


#+BEGIN_SRC emacs-lisp
  (use-package org-projectile
    :ensure t
    :after org-capture
    :bind (("C-c n p" . org-projectile:project-todo-completing-read)
           ("C-c c" . org-capture))
    :config
    (progn
      (setq org-projectile:projects-file (concat org-directory "todo.org"))
      (add-to-list 'org-capture-templates (org-projectile:project-todo-entry "p"))))
#+END_SRC

** Better bullets

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

** Misc
   Here are a few miscellaneous things that make org mode better. 
   #+BEGIN_SRC emacs-lisp
     (setq org-pretty-entities          t ; UTF8 all the things!  
           org-support-shift-select     t ; holding shift and moving point should select things
           org-enforce-todo-dependencies t ; can't finish parent before children
           org-enforce-todo-checkbox-dependencies t ; can't finish parent before children
           org-hide-emphasis-markers t ; make words italic or bold, hide / and *
           org-catch-invisible-edits 'error ; don't let me edit things I can't see
           org-hide-leading-stars t) ; hides extra stars in headers
     (setq org-startup-with-inline-images t) ; show inline images
     (setq org-log-done t)
     (setq org-goto-interface (quote outline-path-completion))
     (setq org-ellipsis "⬎")
     (use-package htmlize
       :ensure t)
   #+END_SRC

   For whatever reason, I have to explicitely tell org how to open pdf links. I use pdf-tools, which is loaded in [[file:load-behavior.org][load-behavior]]. If pdf-tools isn't installed, it will use doc-view (the default in emacs) instead.

   #+BEGIN_SRC emacs-lisp
     (setq org-file-apps
           '((auto-mode . emacs)
             ("\\.mm\\'" . default)
             ("\\.x?html?\\'" . default)
             ("\\.pdf\\'" . emacs)))

   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (setq org-image-actual-width '(300))
   #+END_SRC

   Make =C-a= and =C-e= work more like how I want: 
   
   #+BEGIN_SRC emacs-lisp
     (setq org-special-ctrl-a/e t)
   #+END_SRC

* Shells
  
** Eshell 
Eshell is Emacs' built-in shell. You get UNIX-y goodness even on Windows machines, plus it can evaluate elisp. 

#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :defer t
    :commands (eshell)
    :config
    (setq eshell-cmpl-cycle-completions nil
          ;; auto truncate after 20k lines
          eshell-buffer-maximum-lines 20000
          ;; history size
          eshell-history-size 350
          ;; no duplicates in history
          eshell-hist-ignoredups t
          ;; my prompt is easy enough to see
          eshell-highlight-prompt nil
          ;; treat 'echo' like shell echo
          eshell-plain-echo-behavior t)
    (use-package eshell-prompt-extras
      :ensure t
      :init
      (setq eshell-prompt-function #'epe-theme-lambda)))
#+END_SRC

** Shell pop

#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :ensure t
    :bind ("C-c M-e" . shell-pop)
    :init
    (setq shell-pop-window-position 'bottom
          shell-pop-window-height 33
          shell-pop-full-span t
          shell-pop-shell-type '("eshell" "*eshell*" (eshell))))
#+END_SRC

** Fix for dumb terminal
   Shell-mode uses a "dumb" terminal. Sometimes that's annoying, but this fixes the worst of that:

   #+BEGIN_SRC emacs-lisp
     (setenv "PAGER" "cat")
   #+END_SRC

** Make urls clickable

   #+BEGIN_SRC emacs-lisp
     (add-hook 'shell-mode-hook 'goto-address-mode)
   #+END_SRC

** Shell misc
   Here are a few miscellaneous settings for shell modes, including inferior ~R~ processes used by ~ESS~:
   #+BEGIN_SRC emacs-lisp
     (setq comint-scroll-to-bottom-on-input 'this)
   #+END_SRC
* R (with ESS)
  ESS (Emacs Speaks Statistics) is a [[http://ess.r-project.org/][great project]] and makes Emacs speak with R.

  #+BEGIN_SRC emacs-lisp
    (use-package ess-site 
      :ensure ess
      :diminish eldoc-mode
      :bind
      (:map ess-mode-map
            ("C-a" . crux-move-beginning-of-line))
      :config
      (add-hook 'ess-mode-hook
                (lambda ()
                  (ess-set-style 'RStudio)))
      (setq ess-eval-visibly 'nowait)
      (setq ess-ask-for-ess-directory nil)
      (setq ess-eldoc-show-on-symbol t)
      (setq ess-pdf-viewer-pref "emacsclient")
      (defun my/add-pipe ()
        "Adds a pipe operator %>% with one space to the left and then
    starts a newline with proper indentation"
        (interactive)
        (just-one-space 1)
        (insert "%>%")
        (ess-newline-and-indent))
      (define-key ess-mode-map (kbd "M-p") #'my/add-pipe))
  #+END_SRC

* Python
  The package is called python, the mode is python-mode: 
  #+BEGIN_SRC emacs-lisp
    (use-package python
      :mode ("\\.py\\'". python-mode)
      :interpreter "python")
  #+END_SRC

  Elpy is a ton of customizations for python. Note that I had to add it to ~package-archives~ in [[file:init.el]]. Load it up:

  #+BEGIN_SRC emacs-lisp
    (use-package elpy
      :ensure t
      :init
      (progn
        (elpy-enable))
      :config
      (when (require 'flycheck nil t)
        (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
        (add-hook 'elpy-mode-hook 'flycheck-mode)))
  #+END_SRC

* Stan
  Stan is a Bayesian modeling language. Emacs has a mode for it (of course!)

  #+BEGIN_SRC emacs-lisp
    (use-package stan-mode
      :ensure t
      :mode ("\\.stan\\'". stan-mode))
  #+END_SRC

* Code and syntax checking
  Emacs can tell you magically if your code is wrong (or just ugly). Flycheck is a minor mode for this. Let's enable it globally.

  Flycheck can check your R code too, but you'll need to install the ~lintr~ package.

  #+BEGIN_SRC emacs-lisp
    (use-package flycheck ; checks for style and syntax
      :ensure t
      :diminish flycheck-mode
      :config
      (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
      (add-hook 'after-init-hook #'global-flycheck-mode))

  #+END_SRC

  Electric operator will turn ~a=10*5+2~ into ~a = 10 * 5 + 2~, so let's enable it for R:

  #+BEGIN_SRC emacs-lisp
    (use-package electric-operator
      :ensure t
      :config
      (setq electric-operator-R-named-argument-style 'spaced)
      (add-hook 'ess-mode-hook #'electric-operator-mode)
      (add-hook 'python-mode-hook #'electric-operator-mode))
  #+END_SRC
* Whitespace
  Whitespace is evil. Let's get rid of as much as possible. But we don't want to do this with files that already had whitespace (from someone else's project, for example). This mode will call ~whitespace-cleanup~ before buffers are saved (but smartly)!

  #+BEGIN_SRC emacs-lisp
    (use-package whitespace-cleanup-mode 
      :ensure t
      :diminish whitespace-cleanup-mode
      :config
      (add-hook 'prog-mode-hook #'whitespace-cleanup-mode)
      (add-hook 'ess-mode-hook #'whitespace-cleanup-mode))
  #+END_SRC

* Text Misc
I end sentences with a single space. 

  #+BEGIN_SRC emacs-lisp
    (setq sentence-end-double-space nil)
  #+END_SRC

  Turn on visual line mode for nice line wrapping

  #+BEGIN_SRC emacs-lisp
    (add-hook 'text-mode-hook #'turn-on-visual-line-mode)
  #+END_SRC

  Now that I've turned on ~visual-line-mode~, I want it to respect indentation. This does so:

  #+BEGIN_SRC emacs-lisp
    (use-package adaptive-wrap
      :ensure t
      :config
      (when (fboundp 'adaptive-wrap-prefix-mode)
        (defun my-activate-adaptive-wrap-prefix-mode ()
          "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' simultaneously."
          (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))
        (add-hook 'visual-line-mode-hook #'my-activate-adaptive-wrap-prefix-mode)))
#+END_SRC

  =fill-paragraph= is nice, but emacs weirdly lacks a convenient way to unfill paragraphs once they're filled. This command ([[http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html][credit]]) fixes that.

    #+BEGIN_SRC emacs-lisp
      (defun endless/fill-or-unfill ()
        "Like `fill-paragraph', but unfill if used twice."
        (interactive)
        (let ((fill-column
               (if (eq last-command 'endless/fill-or-unfill)
                   (progn (setq this-command nil)
                          (point-max))
                 fill-column)))
          (call-interactively #'fill-paragraph)))

      (global-set-key [remap fill-paragraph]
                      #'endless/fill-or-unfill)
  #+END_SRC


  #+BEGIN_SRC emacs-lisp
    (defun dcaps-to-scaps ()
      "Convert word in DOuble CApitals to Single Capitals."
      (interactive)
      (and (= ?w (char-syntax (char-before)))
           (save-excursion
             (and (if (called-interactively-p)
                      (skip-syntax-backward "w")
                    (= -3 (skip-syntax-backward "w")))
                  (let (case-fold-search)
                    (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
                  (capitalize-word 1)))))

    (define-minor-mode dubcaps-mode
      "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
    Single Capitals as you type."
      :init-value nil
      :lighter (" DC")
      (if dubcaps-mode
          (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local)
        (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)))

    (add-hook 'text-mode-hook #'dubcaps-mode)
  #+END_SRC

* Markdown
  Markdown mode for Markdown editing! 

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode 
      :ensure t
      :commands (markdown-mode gfm-mode)
      :mode (("README\\.md\\'" . gfm-mode)
             ("\\.md\\'" . markdown-mode)
             ("\\.markdown\\'" . markdown-mode))
      :config
      (setq markdown-enable-math t))
  #+END_SRC

  Of course, markdown contains a yaml header, so we need yaml-mode as well:

  #+BEGIN_SRC emacs-lisp
    (use-package yaml-mode
      :ensure t
      :mode (("\\.yml\\'" . yaml-mode)))
  #+END_SRC

* LaTeX
  AuCTeX is better than the built in tex mode; let's use it. It's good out of the box, but I like to use latexmk so that I don't have to remember to rerun the file X times to get references right.

  #+BEGIN_SRC emacs-lisp
    (use-package tex-site
      :ensure auctex
      :config
      (add-hook 'LaTeX-mode-hook #'LaTeX-math-mode)
      (setq TeX-auto-save t
            TeX-parse-self t
            reftex-plug-into-AUCTeX t)
      (add-hook 'LaTeX-mode-hook #'TeX-PDF-mode)
      (setq TeX-source-correlate-method 'synctex)
      (setq TeX-source-correlate-mode t)
      (eval-after-load "tex"
        '(add-to-list 'TeX-command-list '("latexmk" "latexmk -synctex=1 -shell-escape -pdf %s" TeX-run-TeX nil t :help "Process file with latexmk"))
        )
      (eval-after-load "tex"
        '(add-to-list 'TeX-command-list '("xelatexmk" "latexmk -synctex=1 -shell-escape -xelatex %s" TeX-run-TeX nil t :help "Process file with xelatexmk"))
        )
      (add-hook 'TeX-mode-hook (lambda () (setq TeX-command-default "latexmk"))))
  #+END_SRC

  Finally, sometimes we want wordcounts. If I just want a quick snippet, I can run the following command. If I want more information, I can drop into a shell with ~C-c M-e~ (~shell-pop~) and run ~texcount my-file.tex~:

  #+BEGIN_SRC emacs-lisp
    (defun latex-word-count ()
      (interactive)
      (let* ((this-file (buffer-file-name))
             (word-count
              (with-output-to-string
                (with-current-buffer standard-output
                  (call-process "texcount" nil t nil "-brief" this-file)))))
        (string-match "\n$" word-count)
        (message (replace-match "" nil nil word-count))))
  #+END_SRC

** Reftex
I use =ivy-bibtex= to manage my references, but ReFTeX is still great to have around for cross-references in latex files. 

You will need to change ~reftex-default-bibliography~ to wherever you keep your main .bib file.

#+BEGIN_SRC emacs-lisp
  (use-package reftex
    :commands turn-on-reftex
    :init
    (setq reftex-cite-format 
          '((?\C-m . "\\cite[]{%l}")
            (?t . "\\citet{%l}")
            (?p . "\\citep[]{%l}")
            (?a . "\\autocite{%l}")
            (?A . "\\textcite{%l}")
            (?P . "[@%l]")
            (?T . "@%l [p. ]")
            (?x . "[]{%l}")
            (?X . "{%l}")))
    (setq reftex-default-bibliography '("~/Dropbox/bibliography/references.bib"))
    (setq reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource"))
    (setq reftex-extra-bindings t)
    :config
    (add-hook 'LaTeX-mode-hook #'turn-on-reftex))
#+END_SRC

* Polymode (for knitr)
  Polymode is a (relatively new) way of working with multiple major modes. This is especially helpful if we want to use latex or markdown together with R code.

  #+BEGIN_SRC emacs-lisp
    (use-package polymode 
      :ensure t
      :mode
      ("\\.Snw" . poly-noweb+r-mode)
      ("\\.Rnw" . poly-noweb+r-mode)
      ("\\.[rR]md" . Rmd-mode)
      :init
      (progn
        (defun Rmd-mode ()
          "ESS Markdown mode for Rmd files"
          (interactive)
          (require 'poly-R)
          (require 'poly-markdown)
          (R-mode)
          (poly-markdown+r-mode))))
  #+END_SRC

* Spell Check
Flyspell checks for spelling on the fly. I use aspell instead of ispell because it's better. :-) You may need to install it separately, though I didn't need to. If you want to use non-english words, you can tell it so with ~ispell-local-dictionary~ variable. 

  #+BEGIN_SRC emacs-lisp
    (use-package flyspell
      :ensure t
      :diminish flyspell-mode
      :config
      (setq ispell-program-name "aspell")
      (setq ispell-list-command "--list")
      (add-hook 'text-mode-hook 'turn-on-flyspell)
      (add-hook 'prog-mode-hook 'flyspell-prog-mode)
      (add-hook 'ess-mode-hook 'flyspell-prog-mode))
  #+END_SRC
* Version control
  #+BEGIN_SRC emacs-lisp
    (setq vc-make-backup-files t)
  #+END_SRC
** Git & Magit
Magit is better than the command line for git. I don't modify much. I just bind it to =C-x g=. I also set it up that it will run alone in the frame, then restore your previous window configuration when you exit.

   #+BEGIN_SRC emacs-lisp
     (use-package magit ; for git
       :ensure t
       :bind
       ("C-x g" . magit-status)
       :config
       (setq magit-completing-read-function 'ivy-completing-read)
       (setq magit-push-always-verify nil)
       (setq magit-diff-refine-hunk 'all) ; get highlighted word diffs
       (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
   #+END_SRC

Modes for git files:

#+BEGIN_SRC emacs-lisp
  (use-package gitattributes-mode
    :defer t
    :ensure t)
  (use-package gitconfig-mode
    :defer t
    :ensure t)
  (use-package gitignore-mode
    :defer t
    :ensure t)
#+END_SRC

And to step through the history of a file:

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t
    :commands (git-timemachine))
#+END_SRC

*** Github
This package integrates magit with github. It relies on having [[https://hub.github.com/][hub]] installed already. 
#+BEGIN_SRC emacs-lisp
  (use-package magithub
    :ensure t
    :if (executable-find "hub")
    :after magit)
#+END_SRC

* Webpage editing
** HTML and friends
   Web-mode takes care of a lot of html annoyances: 

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :mode 
       ("\\.html?\\'" . web-mode)
       ("\\.scss?\\'" . web-mode)
       ("\\.erb\\'" . web-mode)
       ("\\.djhtml\\'" . web-mode)
       :config
       (setq web-mode-engines-alist
             '(("django" . "\\.djhtml'"))))
   #+END_SRC

** CSS, SCSS
   And CSS/SCSS is handled nicely by this package: 

   #+BEGIN_SRC emacs-lisp
     (use-package scss-mode
       :ensure t
       :mode
       ("\\.css\\'". css-mode)
       ("\\.scss\\'" . scss-mode))
   #+END_SRC
* Email
** mu4e setup files
   I use ~mu4e~ with mbsync and mu for my email. In order to use this file, you'll need to make sure that mbsync and mu are installed on your system. mbsync requires a bit of configuration to get it started.
** mu4e setup
   Finally, we can get mu4e set up.
   #+BEGIN_SRC emacs-lisp
     (use-package mu4e
       :if (executable-find "mu")
       :bind
       (("<f1>" . my-mu4e-start)
        ("C-x m" . mu4e-compose-new)
        :map mu4e-headers-mode-map
        ("d" . mu4e-headers-mark-for-delete)
        :map mu4e-view-mode-map
        ("d" . mu4e-view-mark-for-delete)
        :map mu4e-main-mode-map
        ("q" . mu4e-quit-session))
       :init
       (setq mu4e-maildir "~/.mail")
       ;; Start mu4e in fullscreen
       (defun my-mu4e-start ()
         (interactive)
         (window-configuration-to-register :mu4e-fullscreen)
         (mu4e)
         (delete-other-windows))
       ;; Restore previous window configuration
       (defun mu4e-quit-session ()
         "Restores the previous window configuration and kills the mu4e buffer"
         (interactive)
         (kill-buffer)
         (jump-to-register :mu4e-fullscreen))
       (add-hook 'after-init-hook
                 (lambda () (mu4e t))) ; starts mu4e silently when emacs starts
       :config
       (setq mu4e-contexts
             `( ,(make-mu4e-context
                  :name "utexas"
                  :enter-func (lambda () (mu4e-message "Switch to utexas context"))
                  ;; leave-func not defined
                  :match-func (lambda (msg)
                                (when msg
                                  (mu4e-message-contact-field-matches msg
                                                                      :to "branham@utexas.edu")))
                  :vars '((mu4e-drafts-folder . "/utexas/[Gmail]/.Drafts")
                          (mu4e-sent-folder . "/utexas/[Gmail]/.Sent Mail")
                          (mu4e-trash-folder . "/utexas/[Gmail]/.Trash")
                          (user-mail-address . "branham@utexas.edu")
                          (user-full-name . "Alex Branham")
                          (mu4e-compose-signature . (concat
                                                     "J. Alexander Branham\n"
                                                     "PhD Candidate\n"
                                                     "Department of Government\n"
                                                     "University of Texas at Austin\n"
                                                     "www.jabranham.com"
                                                     "\n"))))
                ,(make-mu4e-context
                  :name "gmail"
                  :enter-func (lambda () (mu4e-message "Switch to gmail context"))
                  ;; leave-func not defined
                  :match-func (lambda (msg)
                                (when msg
                                  (mu4e-message-contact-field-matches msg
                                                                      :to "alex.branham@gmail.com")))
                  :vars '((user-mail-address . "alex.branham@gmail.com")
                          (user-full-name . "Alex Branham")
                          (mu4e-compose-signature . (""))
                          (mu4e-drafts-folder . "/gmail/[Gmail]/.Drafts")
                          (mu4e-sent-folder . "/gmail/[Gmail]/.Sent Mail")
                          (mu4e-trash-folder . "/gmail/[Gmail]/.Trash")))))
       (setq mu4e-context-policy 'pick-first)
       (setq mu4e-maildir-shortcuts '( ("/utexas/INBOX"  . ?u)
                                       ("/utexas/[Gmail]/.Sent Mail"   . ?s)
                                       ("/utexas/[Gmail]/.All Mail" . ?a)
                                       ("/gmail/INBOX" . ?g)))
       (setq mail-user-agent 'mu4e-user-agent)
       ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
       (setq mu4e-sent-messages-behavior 'delete)
       (setq mu4e-get-mail-command "mbsync -a"   ;; or fetchmail, or ...
             mu4e-update-interval 60)             ;; update every minute
       (setq mu4e-change-filenames-when-moving t)
       ;; setup some handy shortcuts
       ;; you can quickly switch to your Inbox -- press ``ji''
       ;; then, when you want archive some messages, move them to
       ;; the 'All Mail' folder by pressing ``ma''.
       ;; something about ourselves
       (setq mu4e-user-mail-address-list '("branham@utexas.edu" "alex.branham@gmail.com"))
       (setq mu4e-compose-dont-reply-to-self t) ; don't reply to self
       (setq mu4e-compose-complete-only-after "2015-01-01")
       (setq mu4e-view-show-addresses t)
       (setq mu4e-hide-index-messages t)
       (setq mu4e-view-show-images t)
       ;; use imagemagick, if available
       (when (fboundp 'imagemagick-register-types)
         (imagemagick-register-types))
       (setq message-kill-buffer-on-exit t)
       (setq mu4e-use-fancy-chars t)
       (setq mu4e-headers-skip-duplicates t)
       (setq mu4e-attachment-dir "~/Downloads")
       (setq mu4e-completing-read-function 'completing-read)
       (add-hook 'mu4e-view-mode-hook #'visual-line-mode)
       ;; turn off autofill mode in mu4e compose
       (defun autofill-off-visual-on ()
         "Turn off auto-fill-mode and turn on visual-mode"
         (auto-fill-mode -1)
         (visual-line-mode))
       (add-hook 'mu4e-compose-mode-hook #'autofill-off-visual-on)
       ;; use aV to open message in browser
       (add-to-list 'mu4e-view-actions
                    '("ViewInBrowser" . mu4e-action-view-in-browser) t)
       (use-package gnus-dired
         ;; make the `gnus-dired-mail-buffers' function also work on
         ;; message-mode derived modes, such as mu4e-compose-mode
         :config
         (defun gnus-dired-mail-buffers ()
           "Return a list of active message buffers."
           (let (buffers)
             (save-current-buffer
               (dolist (buffer (buffer-list t))
                 (set-buffer buffer)
                 (when (and (derived-mode-p 'message-mode)
                            (null message-sent-message-via))
                   (push (buffer-name buffer) buffers))))
             (nreverse buffers)))
         (setq gnus-dired-mail-mode 'mu4e-user-agent)
         (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode))
       ;; configure orgmode support in mu4e
       (use-package org-mu4e
         ;; when mail is sent, automatically convert org body to HTML
         :config
         (setq org-mu4e-convert-to-html t))
       (use-package mu4e-maildirs-extension
         :ensure t
         :config
         (setq mu4e-maildirs-extension-custom-list
               '("/utexas/INBOX"
                 "/gmail/INBOX"))
         (mu4e-maildirs-extension-load))
       ) ; finishes use-package mu4e
   #+END_SRC
** Helper for yasnippet

   This function helps with an expandable snippet. [[http://pragmaticemacs.com/emacs/email-templates-in-mu4e-with-yasnippet/][link]]


   #+BEGIN_SRC emacs-lisp
     ;; function to return first name of email recipients
     ;; used by yasnippet
     ;; inspired by
     ;;http://blog.binchen.org/posts/how-to-use-yasnippets-to-produce-email-templates-in-emacs.html
     (defun bjm/mu4e-get-names-for-yasnippet ()
       "Return comma separated string of names for an email"
       (interactive)
       (let ((email-name "") str email-string email-list email-name2 tmpname)
         (save-excursion
           (goto-char (point-min))
           ;; first line in email could be some hidden line containing NO to field
           (setq str (buffer-substring-no-properties (point-min) (point-max))))
         ;; take name from TO field - match series of names
         (when (string-match "^To: \"?\\(.+\\)" str)
           (setq email-string (match-string 1 str)))
         ;;split to list by comma
         (setq email-list (split-string email-string " *, *"))
         ;;loop over emails
         (dolist (tmpstr email-list)
           ;;get first word of email string
           (setq tmpname (car (split-string tmpstr " ")))
           ;;remove whitespace or ""
           (setq tmpname (replace-regexp-in-string "[ \"]" "" tmpname))
           ;;join to string
           (setq email-name
                 (concat email-name ", " tmpname)))
         ;;remove initial comma
         (setq email-name (replace-regexp-in-string "^, " "" email-name))

         ;;see if we want to use the name in the FROM field
         ;;get name in FROM field if available, but only if there is only
         ;;one name in TO field
         (if (< (length email-list) 2)
             (when (string-match "^\\([^ ,\n]+\\).+writes:$" str)
               (progn (setq email-name2 (match-string 1 str))
                      ;;prefer name in FROM field if TO field has "@"
                      (when (string-match "@" email-name)
                        (setq email-name email-name2))
                      )))
         email-name))
   #+END_SRC

** Sending mail
   #+BEGIN_SRC emacs-lisp
     (when (executable-find "mu")
       (use-package smtpmail
         :config
         (setq message-send-mail-ggfunction 'smtpmail-send-it
               smtpmail-stream-type 'starttls
               smtpmail-default-smtp-server "smtp.gmail.com"
               smtpmail-smtp-server "smtp.gmail.com"
               smtpmail-smtp-service 587
               send-mail-function 'smtpmail-send-it))

                                             ; warn if no attachments
       (defun mbork/message-attachment-present-p ()
         "Return t if an attachment is found in the current message."
         (save-excursion
           (save-restriction
             (widen)
             (goto-char (point-min))
             (when (search-forward "<#part" nil t) t))))

       (defcustom mbork/message-attachment-intent-re
         (regexp-opt '("I attach"
                       "I have attached"
                       "I've attached"
                       "I have included"
                       "I've included"
                       "see the attached"
                       "see the attachment"
                       "attached file"))
         "A regex which - if found in the message, and if there is no
     attachment - should launch the no-attachment warning.")

       (defcustom mbork/message-attachment-reminder
         "Are you sure you want to send this message without any attachment? "
         "The default question asked when trying to send a message
     containing `mbork/message-attachment-intent-re' without an
     actual attachment.")

       (defun mbork/message-warn-if-no-attachments ()
         "Ask the user if s?he wants to send the message even though
     there are no attachments."
         (when (and (save-excursion
                      (save-restriction
                        (widen)
                        (goto-char (point-min))
                        (re-search-forward mbork/message-attachment-intent-re nil t)))
                    (not (mbork/message-attachment-present-p)))
           (unless (y-or-n-p mbork/message-attachment-reminder)
             (keyboard-quit))))

       (add-hook 'message-send-hook #'mbork/message-warn-if-no-attachments)


       (use-package mu4e-alert
         :ensure t
         :config
         ;; Choose the style you prefer for desktop notifications
         ;; If you are on Linux you can use
         ;; 1. notifications - Emacs lisp implementation of the Desktop Notifications API
         ;; 2. libnotify     - Notifications using the `notify-send' program, requires `notify-send' to be in PATH
         ;;
         ;; On Mac OSX you can set style to
         ;; 1. notifier      - Notifications using the `terminal-notifier' program, requires `terminal-notifier' to be in PATH
         ;; 1. growl         - Notifications using the `growl' program, requires `growlnotify' to be in PATH
         (mu4e-alert-set-default-style 'libnotify)
         (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
         (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
         (setq mu4e-alert-interesting-mail-query
               (concat
                "flag:unread"
                " AND "
                " maildir:\"/utexas/INBOX\""
                " OR maildir:\"/gmail/INBOX\""
                " AND flag:unread"))))
   #+END_SRC

* Feed reader

I use [[https://github.com/skeeto/elfeed][elfeed]] to manage some RSS links:

#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure t
    :bind
    (("<f7>" . bjm/elfeed-load-db-and-open)
     :map elfeed-search-mode-map
     ("q" . bjm/elfeed-save-db-and-bury))
    :init
    ;; thanks - http://pragmaticemacs.com/emacs/read-your-rss-feeds-in-emacs-with-elfeed/
    ;; though slightly modified
    ;; functions to support syncing .elfeed between machines
    ;; makes sure elfeed reads index from disk before launching
    (defun bjm/elfeed-load-db-and-open ()
      "Load the elfeed db from disk before opening."
      (interactive)
      (elfeed-db-load)
      (elfeed)
      (elfeed-search-update--force)
      (elfeed-update))
    ;;write to disk when quiting
    (defun bjm/elfeed-save-db-and-bury ()
      "Wrapper to save the elfeed db to disk before burying buffer"
      (interactive)
      (elfeed-db-save)
      (quit-window))
    :config
    (setq elfeed-db-directory "~/Dropbox/.elfeed")
    (setq-default elfeed-search-filter "@1-week-ago +unread ")

    ;; This lets me get the http links to entries with org-capture
    ;; easily.
    (defun elfeed-entry-as-html-link ()
      "Store an http link to an elfeed entry"
      (when (equal major-mode 'elfeed-show-mode)
        (let ((description (elfeed-entry-title elfeed-show-entry))
              (link (elfeed-entry-link elfeed-show-entry)))
          (org-store-link-props
           :type "http"
           :link link
           :description description))))
    (add-hook 'org-store-link-functions #'elfeed-entry-as-html-link))
#+END_SRC

[[https://github.com/remyhonig/elfeed-org][elfeed-org]] lets me store my subscriptions in a more sane way:

#+BEGIN_SRC emacs-lisp
  (use-package elfeed-org
    :ensure t
    :config
    (elfeed-org))
#+END_SRC

* Ledger
[[http://ledger-cli.org/][Ledger]] is a program that I use to keep track of finances. Emacs, of course, can handle it quite nicely. 
#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :ensure t
    :if (executable-find "ledger")
    :mode ("\\.ledger$" . ledger-mode))
#+END_SRC
