#+author: J. Alexander Branham
#+STARTUP: indent
#+title: Emacs settings

* Behavior 
  Tell emacs a bit about ourselves:
  #+BEGIN_SRC emacs-lisp
    (setq
     user-mail-address "branham@utexas.edu"
     user-full-name  "Alex Branham")
  #+END_SRC

  I use ~desktop-clear~ to get rid of buffers and other things every now and then. Let's bind it to f12:

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "<f12>") #'desktop-clear)
  #+END_SRC

  C-x C-c is originally bound to kill emacs. I accidentally type this from time to time which is super-frustrating. Get rid of it:

  #+BEGIN_SRC emacs-lisp
    (global-unset-key (kbd "C-x C-c"))
  #+END_SRC
  
  In my world, =C-z= is undo, not minimize emacs:

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-z") #'undo)
    (define-key evil-emacs-state-map (kbd "C-z") #'undo)
  #+END_SRC

    I don't work much with emacs-lisp, so the scratch buffer shouldn't be in emacs-lisp mode:

    Emacs "kills" and "yanks" instead of cutting and pasting. Using this, we can ~C-w~ and that will kill the active region (whatever you have selected). If you haven't selected anything, it'll kill the line it's on.
    #+BEGIN_SRC emacs-lisp
      ;; http://emacs-fu.blogspot.co.uk/2009/11/copying-lines-without-selecting-them.html
      (defadvice kill-region (before slick-cut activate compile)
        "When called interactively with no active region, kill a single line instead."
        (interactive
         (if mark-active (list (region-beginning) (region-end))
           (list (line-beginning-position)
                 (line-beginning-position 2)))))

      (bind-key "C-w" 'kill-region)
    #+END_SRC

** File finder (Dired)
   Emacs can act as your file finder/explorer. Dired is the built-in way to do this.

   #+BEGIN_SRC emacs-lisp
     (setq dired-auto-revert-buffer t)
     (setq dired-dwim-target t)
     (setq dired-recursive-copies (quote always))
     (setq dired-recursive-deletes (quote always))
     ;; Hide details (owner, permissions) in dired
     (add-hook 'dired-mode-hook
               (lambda () (dired-hide-details-mode 1)))
   #+END_SRC

   Here I sort dired buffers with directories (folders) first, then everything else:

   #+BEGIN_SRC emacs-lisp
     (defadvice dired-readin (after dired-after-updating-hook first () activate)
       "Sort dired listings with directories first before adding marks."
       (save-excursion
         (let (buffer-read-only)
           (forward-line 2) ;; beyond dir. header
           (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
         (set-buffer-modified-p nil)))
   #+END_SRC

   This lets me make directories on the fly similar to =mkdir -p=. [[http://mbork.pl/2016-07-25_Making_directories_on_the_fly][Thanks!]]

   #+BEGIN_SRC emacs-lisp
     (defun make-parent-directory ()
       "Make sure the directory of `buffer-file-name' exists."
       (make-directory (file-name-directory buffer-file-name) t))

     (add-hook 'find-file-not-found-functions #'make-parent-directory)
   #+END_SRC

** Passwords
   I use [[https://www.passwordstore.org/][pass]] to manage all my passwords and login info. This lets me easily access it from within emacs:

   #+BEGIN_SRC emacs-lisp
     (use-package password-store
       :if (executable-find "pass")
       :commands (password-store-copy password-store-edit)
       :config
       (setq password-store-password-length 20))
   #+END_SRC
** Auto indent

   [[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent mode]] keeps code indented automatically, even after rearranging stuff:

   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent
       :ensure t
       :config
       (global-aggressive-indent-mode)
       (add-to-list 'aggressive-indent-excluded-modes 'inferior-ess-mode))
   #+END_SRC

** Browser
Use Emacs' built in =eww= broswer by default. If a webpage requires more, I can switch to the system default by tapping =&=:

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function
        '((".*login.utexas.*" . browse-url-firefox)
          (".*utdirect.*utexas.*" . browse-url-firefox)
          (".*github.*" . browse-url-firefox)
          (".*youtube.*" . browse-url-firefox)
          (".*youtu.be*" . browse-url-firefox)
          ("." . eww-browse-url)))
#+END_SRC

By default, =M-s M-w= searches for text in the region. I change it to search for text in region if active, prompt otherwise:
#+BEGIN_SRC emacs-lisp
  (defun jab/eww-search (orig-fun &rest args)
    (if (region-active-p) (apply orig-fun args)
      (eww (read-string "Query: "))))
  (advice-add 'eww-search-words :around #'jab/eww-search)
#+END_SRC

** Scrolling

#+BEGIN_SRC emacs-lisp
  (use-package view
    :bind
    ("C-v" . View-scroll-half-page-forward)
    ("M-v" . View-scroll-half-page-backward))

#+END_SRC

** Miscellaneous
   Here are a bunch of things I want emacs to do (or not) but don't seem to fit in other sections.

*** Prettify symbols
Prettify-symbols-mode will replace some symbols (like "lambda") with their prettier cousins (like \lambda). 

#+BEGIN_SRC emacs-lisp
  (setq prettify-symbols-unprettify-at-point 'right-edge)
  (global-prettify-symbols-mode)
#+END_SRC

*** Replace selected text
    Emacs by default doesn't replace selected text if you start typing over it. Since that's the behavior of virtually all other programs, let's make emacs do that too:

    #+BEGIN_SRC emacs-lisp
      (delete-selection-mode)
    #+END_SRC

*** Backup files
    I want emacs to make these, but don't want to clutter up my project folders with tons of backup files. Solution: put them in the ~.emacs.d/~ directory.
    #+BEGIN_SRC emacs-lisp
      (setq backup-directory-alist
            `(("." . ,(expand-file-name
                       (concat user-emacs-directory "backups")))))
    #+END_SRC

*** Resize windows
    We can resize windows now! 
     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
       (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
       (global-set-key (kbd "S-C-<down>") 'shrink-window)
       (global-set-key (kbd "S-C-<up>") 'enlarge-window)
     #+END_SRC
*** Move around quickly
    You can ~C-n~ and whatnot to go by line, but sometimes I want to move a bit more quickly than that. Using ~C-S-n~ will now let me:

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-S-n")
                      (lambda ()
                        (interactive)
                        (ignore-errors (next-line 5))))

      (global-set-key (kbd "C-S-p")
                      (lambda ()
                        (interactive)
                        (ignore-errors (previous-line 5))))

      (global-set-key (kbd "C-S-f")
                      (lambda ()
                        (interactive)
                        (ignore-errors (forward-char 5))))

      (global-set-key (kbd "C-S-b")
                      (lambda ()
                        (interactive)
                        (ignore-errors (backward-char 5))))
    #+END_SRC

* Functions
** Jekyll functions
   I use ~jekyll-publish-draft~ to move a post from _drafts/ to _posts/ which publishes it to my blog. Inspiration from [[http://pasoev.github.io/programming/2015/10/31/jekyll-posts-emacs-capture/][here]]

   #+BEGIN_SRC emacs-lisp
     (defun today-is ()
       "Return current year-month-day."
       (format-time-string "%Y-%m-%d"))

     (defun jekyll-drafts ()
       (let ((default-directory
               (concat (projectile-project-root) "_drafts")))
         (file-expand-wildcards "*.md")))

     (defun jekyll-publish-draft (post)
       "Mark one of the posts from the Jekyll drafts directory as published.
        This actually means moving the post from the _drafts to the _posts 
        directory."
       (interactive
        (list (completing-read "Post to publish: "
                               (jekyll-drafts) nil t "")))
       (copy-file (concat (projectile-project-root) "_drafts/" post)
                  (concat (projectile-project-root) "_posts/" (today-is) "-" post))
       (delete-file (concat (projectile-project-root) "_drafts/" post)))

   #+END_SRC

** Swap horizontal and vertical windows
   Sometimes I want horizontal windows to be vertical or vice versa. This lets me make that happen:

   #+BEGIN_SRC emacs-lisp
     (defun toggle-window-split ()
       (interactive)
       (if (= (count-windows) 2)
           (let* ((this-win-buffer (window-buffer))
                  (next-win-buffer (window-buffer (next-window)))
                  (this-win-edges (window-edges (selected-window)))
                  (next-win-edges (window-edges (next-window)))
                  (this-win-2nd (not (and (<= (car this-win-edges)
                                              (car next-win-edges))
                                          (<= (cadr this-win-edges)
                                              (cadr next-win-edges)))))
                  (splitter
                   (if (= (car this-win-edges)
                          (car (window-edges (next-window))))
                       'split-window-horizontally
                     'split-window-vertically)))
             (delete-other-windows)
             (let ((first-win (selected-window)))
               (funcall splitter)
               (if this-win-2nd (other-window 1))
               (set-window-buffer (selected-window) this-win-buffer)
               (set-window-buffer (next-window) next-win-buffer)
               (select-window first-win)
               (if this-win-2nd (other-window 1))))))
   #+END_SRC
** Splitting windows
   These functions make splitting windows behave more like I want it to. This way, calling ~C-x 2~ or ~C-x 3~ both splits the window /and/ shows the last buffer.

   #+BEGIN_SRC emacs-lisp
     (defun my/vsplit-last-buffer (prefix)
       "Split the window vertically and display the previous buffer."
       (interactive "p")
       (split-window-vertically)
       (other-window 1 nil)
       (if (= prefix 1)
           (switch-to-next-buffer)))
     (defun my/hsplit-last-buffer (prefix)
       "Split the window horizontally and display the previous buffer."
       (interactive "p")
       (split-window-horizontally)
       (other-window 1 nil)
       (if (= prefix 1) (switch-to-next-buffer)))
     (bind-key "C-x 2" 'my/vsplit-last-buffer)
     (bind-key "C-x 3" 'my/hsplit-last-buffer)
   #+END_SRC
** Calc
   From [[https://www.reddit.com/r/emacs/comments/445w6s/whats_some_small_thing_in_your_dotemacs_that_you/][this reddit thread]]

   #+BEGIN_SRC emacs-lisp
     (defun my/calc-eval-region (arg)
       "Evaluate an expression in calc and communicate the result.

     If the region is active evaluate that, otherwise search backwards
     to the first whitespace character to find the beginning of the
     expression. By default, replace the expression with its value. If
     called with the universal prefix argument, keep the expression
     and insert the result into the buffer after it. If called with a
     negative prefix argument, just echo the result in the
     minibuffer."
       (interactive "p")
       (let (start end)
         (if (use-region-p)
             (setq start (region-beginning) end (region-end))
           (progn
             (setq end (point))
             (setq start (search-backward-regexp "\\s-\\|\n" 0 1))
             (setq start (1+ (if start start 0)))
             (goto-char end)))
         (let ((value (calc-eval (buffer-substring-no-properties start end))))
           (pcase arg
             (1 (delete-region start end))
             (4 (insert " = ")))
           (pcase arg
             ((or 1 4) (insert value))
             (-1 (message value))))))
   #+END_SRC
** Insert file name

This function ([[http://pragmaticemacs.com/emacs/insert-file-name/][credit]]) lets me insert a file name easily. Defaults to relative path, use the universal argument to get the absolute path.

   #+BEGIN_SRC emacs-lisp
     (defun my/insert-file-name (filename &optional args)
       "Insert name of file FILENAME into buffer after point.

       Prefixed with \\[universal-argument], expand the file name to
       its fully canocalized path.  See `expand-file-name'.

       Prefixed with \\[negative-argument], use relative path to file
       name from current directory, `default-directory'.  See
       `file-relative-name'.

       The default with no prefix is to insert the file name exactly as
       it appears in the minibuffer prompt."
       ;; Based on insert-file in Emacs -- ashawley 20080926
       (interactive "*fInsert file name: \nP")
       (cond ((eq '- args)
              (insert (expand-file-name filename)))
             ((not (null args))
              (insert (filename)))
             (t
              (insert (file-relative-name filename)))))
   #+END_SRC

* References (ivy-bibtex)
   #+BEGIN_SRC emacs-lisp
     (setq org-ref-default-bibliography '("~/Dropbox/bibliography/references.bib")
           org-ref-pdf-directory "~/Dropbox/bibliography/bibtex-pdfs/"
           org-ref-bibliography-notes "~/Dropbox/bibliography/notes.org")
     (setq bibtex-completion-bibliography '("~/Dropbox/bibliography/references.bib")
           bibtex-completion-library-path "~/Dropbox/bibliography/bibtex-pdfs"
           bibtex-completion-notes-path "~/Dropbox/bibliography/notes.org")
     (bind-keys* ("C-c C-r" . ivy-bibtex))
     (setq bibtex-autokey-titleword-length 0
           bibtex-autokey-titleword-separator ""
           bibtex-autokey-titlewords 0
           bibtex-autokey-year-length 4
           bibtex-autokey-year-title-separator "")
     (setq bibtex-align-at-equal-sign t)
     (setq bibtex-completion-notes-template-one-file
           "\n* TODO ${year} - ${title}\n  :PROPERTIES:\n  :Custom_ID: ${=key=}\n  :AUTHOR: ${author}\n  :JOURNAL: ${journal}\n  :YEAR: ${year}\n  :VOLUME: ${volume}\n  :PAGES: ${pages}\n  :DOI: ${doi}\n  :URL: ${url}\n :END:\n")
     (setq bibtex-completion-cite-commands '("autocite" "textcite" "citep" "citet" "citeauthor" "citeyear" "Citep" "Citet"))
     (setq ivy-bibtex-default-action #'ivy-bibtex-insert-citation)

     ;; temporary fix so that I can bind C-c C-r globally yet still have
     ;; ivy-bibtex insert autocite: citations in org-mode
     (defun bibtex-completion-format-citation-org-autocite (keys)
       "Formatter for org autocite references."
       (s-join ", "
               (--map (format "autocite:%s" it) keys)))
     (setq bibtex-completion-format-citation-functions
           '((org-mode . bibtex-completion-format-citation-org-autocite)
             (latex-mode . bibtex-completion-format-citation-cite)
             (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
             (default . bibtex-completion-format-citation-default)))
   #+END_SRC

* Org
  Org mode is a great thing. I use it for writing academic papers, managing my schedule, managing my references and notes, writing presentations, writing lecture slides, and pretty much anything else. This file is written in org-mode.

** Exporting
   HTML and latex shown by default, let's add markdown:

   #+BEGIN_SRC emacs-lisp
     (use-package ox-md)
   #+END_SRC

   I use xelatexmk so that org uses xelatex by default. I really like the [[https://github.com/matze/mtheme][metropolis beamer theme.]]

   #+BEGIN_SRC emacs-lisp
     (setq org-latex-pdf-process (list "latexmk -f -shell-escape -xelatex %f"))
   #+END_SRC

   This makes org export smart quotes so that it uses ~``word``~ style quotes for latex export:

   #+BEGIN_SRC emacs-lisp
     (setq org-export-with-smart-quotes t)
   #+END_SRC

   This lets me override all the export variables with a =#+BIND:= statement at the beginning of org-mode files for export:

   #+BEGIN_SRC emacs-lisp
     (setq org-export-allow-bind-keywords t)
   #+END_SRC

   Remove =<...>= from timestamps when exporting to latex. [[http://stackoverflow.com/questions/23297422/org-mode-timestamp-format-when-exported][Thanks]]

   #+BEGIN_SRC emacs-lisp
     (defun my/org-export-filter-timestamp-remove-brackets (timestamp backend info)
       "removes relevant brackets from a timestamp"
       (cond
        ((org-export-derived-backend-p backend 'latex)
         (replace-regexp-in-string "[<>]\\|[][]" "" timestamp))
        ((org-export-derived-backend-p backend 'html)
         (replace-regexp-in-string "&[lg]t;\\|[][]" "" timestamp))))

     (eval-after-load 'ox '(add-to-list
                            'org-export-filter-timestamp-functions
                            'my/org-export-filter-timestamp-remove-brackets))
   #+END_SRC

** Code blocks (org-babel)
   Org-babel is included in org. We just need to tell it which languages to load. And don't ask us if we're sure we want to run code blocks when we ~C-c C-c~. Finally, open the code block in the current window when we use ~C-'~

   #+BEGIN_SRC emacs-lisp
     (setq org-confirm-babel-evaluate nil)
     (setq org-src-window-setup 'current-window)
   #+END_SRC

*** Code block font locking
    This will make the contents of code blocks use the same font locking (syntax highlighting) as the major mode. It'll also make the tab key act like you want it to inside code blocks.

    #+BEGIN_SRC emacs-lisp
      (setq org-src-fontify-natively     t
            org-src-tab-acts-natively    t)
    #+END_SRC

*** Adding SRC blocks
    Here I define a function ([[https://github.com/vdemeester/emacs-config/blob/master/.emacs.d/emacs.org][thanks!]]) that lets me easily add and edit source blocks in org mode:

    #+BEGIN_SRC emacs-lisp
      (defun my/org-insert-src-block (src-code-type)
        "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
        (interactive
         (let ((src-code-types
                '("emacs-lisp" "python" "sh"  "css" "calc" "R" "sass" "latex" "lisp" "matlab" "org")))
           (list (ido-completing-read "Source code type: " src-code-types))))
        (progn
          (newline-and-indent)
          (insert (format "#+BEGIN_SRC %s\n" src-code-type))
          (newline-and-indent)
          (insert "#+END_SRC\n")
          (previous-line 2)
          (org-edit-src-code)))

      (define-key org-mode-map (kbd "C-c s a") 'my/org-insert-src-block)
    #+END_SRC

** References (org-ref) 
   I use org-ref to manage my references. 
   #+BEGIN_SRC emacs-lisp
     (setq org-ref-default-citation-link "autocite")
     (defvar my/notes-template
       "* TODO %y - %t\n :PROPERTIES:\n  :Custom_ID: %k\n  :AUTHOR: %9a\n  :JOURNAL: %j\n  :YEAR: %y\n  :VOLUME: %v\n  :PAGES: %p\n  :DOI: %D\n  :URL: %U\n :END:\n")
     (setq org-ref-note-title-format my/notes-template)
   #+END_SRC

** Latex math
   Cdlatex lets me write latex in org-mode. It's particularly useful for math. [[https://www.gnu.org/software/emacs/manual/html_node/org/CDLaTeX-mode.html][doc]]

   #+BEGIN_SRC emacs-lisp
     (use-package cdlatex
       :diminish org-cdlatex-mode
       :config
       (progn
         (add-hook 'org-mode-hook 'org-cdlatex-mode)))
   #+END_SRC

** Agenda
   I also don't want finished TODO items to appear in my agenda:
   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-skip-deadline-if-done t
           org-agenda-skip-scheduled-if-done t
           org-deadline-warning-days 3)
   #+END_SRC

   Finally, set up some nice global keybindings for accessing the agenda:

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-'") 'org-cycle-agenda-files)
   #+END_SRC

   By default, org binds =C-c [= to =org-agenda-file-to-front=, which I find annoying. This removes that:


   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook
               (lambda()
                 (local-unset-key (kbd "C-c ["))))
   #+END_SRC

** Capture

   #+BEGIN_SRC emacs-lisp
     (setq org-default-notes-file (concat org-directory "todo.org"))
   #+END_SRC

*** Firefox


    #+BEGIN_SRC emacs-lisp
      (require 'org-protocol)
    #+END_SRC

*** Capture templates

    #+BEGIN_SRC emacs-lisp
      (setq org-capture-templates
            (quote (
                    ("s" "store" entry (file+headline (concat org-directory "todo.org") "Tasks")
                     "* TODO %?\n   %a")
                    ("t" "task" entry (file+headline (concat org-directory "todo.org") "Tasks")
                     "* TODO %?")
                    ("x" "firefox" entry (file+headline (concat org-directory "todo.org") "Firefox")
                     "* TODO %c" :immediate-finish t))))
    #+END_SRC

** Refile
   Org-refile lets me quickly move around headings in org files. It plays nicely with org-capture, which I use to turn emails into TODOs easily (among other things, of course)

   #+BEGIN_SRC emacs-lisp
     (setq org-outline-path-complete-in-steps nil)
     (setq org-refile-allow-creating-parent-nodes (quote confirm))
     (setq org-refile-use-outline-path t)
     (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
   #+END_SRC
** Misc
   Here are a few miscellaneous things that make org mode better. 
   #+BEGIN_SRC emacs-lisp
     (setq org-pretty-entities          t ; UTF8 all the things!  
           org-enforce-todo-dependencies t ; can't finish parent before children
           org-enforce-todo-checkbox-dependencies t ; can't finish parent before children
           org-hide-emphasis-markers t ; make words italic or bold, hide / and *
           org-catch-invisible-edits 'error) ; don't let me edit things I can't see
     (setq org-goto-interface (quote outline-path-completion))
     (setq org-ellipsis "â¬Ž")
   #+END_SRC

   For whatever reason, I have to explicitely tell org how to open pdf links. I use pdf-tools, which is loaded in [[file:load-behavior.org][load-behavior]]. If pdf-tools isn't installed, it will use doc-view (the default in emacs) instead.

   #+BEGIN_SRC emacs-lisp
     (setq org-file-apps
           '((auto-mode . emacs)
             ("\\.mm\\'" . default)
             ("\\.x?html?\\'" . default)
             ("\\.pdf\\'" . emacs)))

   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (setq org-image-actual-width '(300))
   #+END_SRC

   Make =C-a= and =C-e= work more like how I want: 
   
   #+BEGIN_SRC emacs-lisp
     (setq org-special-ctrl-a/e t)
   #+END_SRC
*** Org-eww
Org-eww lets me capture eww webpages with org-mode

#+BEGIN_SRC emacs-lisp
  (use-package org-eww)
#+END_SRC

* Shells

#+BEGIN_SRC emacs-lisp
  (setq shell-default-shell 'eshell)
#+END_SRC

** Fix for dumb terminal
   Shell-mode uses a "dumb" terminal. Sometimes that's annoying, but this fixes the worst of that:

   #+BEGIN_SRC emacs-lisp
     (setenv "PAGER" "cat")
   #+END_SRC

** Make urls clickable

   #+BEGIN_SRC emacs-lisp
     (add-hook 'shell-mode-hook 'goto-address-mode)
   #+END_SRC

** Shell misc
   Here are a few miscellaneous settings for shell modes, including inferior ~R~ processes used by ~ESS~:
   #+BEGIN_SRC emacs-lisp
     (setq comint-scroll-to-bottom-on-input 'this)
   #+END_SRC
* R (with ESS)
  ESS (Emacs Speaks Statistics) is a [[http://ess.r-project.org/][great project]] and makes Emacs speak with R.

  #+BEGIN_SRC emacs-lisp
      (setq ess-eval-visibly 'nowait)
      (setq ess-ask-for-ess-directory nil)
      (setq ess-eldoc-show-on-symbol t)
      (setq ess-pdf-viewer-pref "emacsclient")
      (defun my/add-pipe ()
        "Adds a pipe operator %>% with one space to the left and then
    starts a newline with proper indentation"
        (interactive)
        (just-one-space 1)
        (insert "%>%")
        (ess-newline-and-indent))
    ;; (define-key ess-mode-map (kbd "M-p") #'my/add-pipe)
    ;; (define-key ess-mode-map (kbd "C-h h") #'ess-help)
    ;; (define-key inferior-ess-mode-map (kbd "C-h h") #'ess-help)
  #+END_SRC

* Electric operator
Electric operator will turn ~a=10*5+2~ into ~a = 10 * 5 + 2~, so let's enable it for R:

  #+BEGIN_SRC emacs-lisp
    (use-package electric-operator
      :ensure t
      :config
      (setq electric-operator-R-named-argument-style 'spaced)
      (add-hook 'ess-mode-hook #'electric-operator-mode)
      (add-hook 'python-mode-hook #'electric-operator-mode))
  #+END_SRC
* Markdown

  Markdown mode for Markdown editing! 

  #+BEGIN_SRC emacs-lisp
      (setq markdown-enable-math t)
  #+END_SRC
* Version control
  #+BEGIN_SRC emacs-lisp
    (setq vc-make-backup-files t)
  #+END_SRC
** Git & Magit
Magit is better than the command line for git. I don't modify much. I just bind it to =C-x g=. I also set it up that it will run alone in the frame, then restore your previous window configuration when you exit.

   #+BEGIN_SRC emacs-lisp
     (setq magit-diff-refine-hunk 'all) ; get highlighted word diffs
     (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
   #+END_SRC

* Email
** mu4e setup files
   I use ~mu4e~ with mbsync and mu for my email. In order to use this file, you'll need to make sure that mbsync and mu are installed on your system. mbsync requires a bit of configuration to get it started.
** mu4e setup
   Finally, we can get mu4e set up. 
   #+BEGIN_SRC emacs-lisp
     (progn
       (spacemacs/set-leader-keys "a M" #'my-mu4e-start)
       (global-set-key (kbd "C-x m") 'mu4e-compose-new))
     (bind-keys
      :map mu4e-headers-mode-map
      ("d" . mu4e-headers-mark-for-delete)
      :map mu4e-view-mode-map
      ("d" . mu4e-view-mark-for-delete)
      :map mu4e-main-mode-map
      ("q" . mu4e-quit-session))
     (setq mail-user-agent 'mu4e-user-agent)
     ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
     (setq mu4e-sent-messages-behavior 'delete)
     (setq
      mu4e-get-mail-command "mbsync -a"   ;; or fetchmail, or ...
      mu4e-update-interval 60)             ;; update every minute
     (setq mu4e-change-filenames-when-moving t)
     ;; setup some handy shortcuts
     ;; you can quickly switch to your Inbox -- press ``ji''
     ;; then, when you want archive some messages, move them to
     ;; the 'All Mail' folder by pressing ``ma''.
     (setq mu4e-maildir-shortcuts
           '( ("/INBOX"  . ?i)
              ("/[Gmail]/.Sent Mail"   . ?s)
              ("/[Gmail]/.Trash"  . ?t)
              ("/[Gmail]/.All Mail" . ?a)))
     ;; something about ourselves
     (setq mu4e-user-mail-address-list '("branham@utexas.edu"))
     (setq mu4e-compose-signature
           (concat
            "J. Alexander Branham\n"
            "PhD Candidate\n"
            "Department of Government\n"
            "University of Texas at Austin\n"
            "www.jabranham.com"
            "\n"))
     (setq mu4e-compose-dont-reply-to-self t) ; don't reply to self
     (setq mu4e-compose-complete-only-after "2015-01-01")
     (setq mu4e-view-show-addresses t)
     (setq mu4e-hide-index-messages t)
     (setq mu4e-view-show-images t)
     ;; use imagemagick, if available
     (when (fboundp 'imagemagick-register-types)
       (imagemagick-register-types))
     (setq message-kill-buffer-on-exit t)
     (setq mu4e-use-fancy-chars t)
     (setq mu4e-headers-skip-duplicates t)
     (setq mu4e-attachment-dir "~/Downloads")
     (add-hook 'mu4e-view-mode-hook #'visual-line-mode)
     ;; turn off autofill mode in mu4e compose
     (defun autofill-off-visual-on ()
       "Turn off auto-fill-mode and turn on visual-mode"
       (auto-fill-mode -1)
       (visual-line-mode))
     (add-hook 'mu4e-compose-mode-hook #'autofill-off-visual-on)
     (use-package gnus-dired
       ;; make the `gnus-dired-mail-buffers' function also work on
       ;; message-mode derived modes, such as mu4e-compose-mode
       :config
       (defun gnus-dired-mail-buffers ()
         "Return a list of active message buffers."
         (let (buffers)
           (save-current-buffer
             (dolist (buffer (buffer-list t))
               (set-buffer buffer)
               (when (and (derived-mode-p 'message-mode)
                          (null message-sent-message-via))
                 (push (buffer-name buffer) buffers))))
           (nreverse buffers)))
       (setq gnus-dired-mail-mode 'mu4e-user-agent)
       (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode))
     ;; configure orgmode support in mu4e
     (use-package org-mu4e
       ;; when mail is sent, automatically convert org body to HTML
       :config
       (setq org-mu4e-convert-to-html t))
     ;; need to do org-mu4e-compose-org-mode
     ;; and include #+OPTIONS: tex:imagemagick
     ;; then send while in headers for this to work properly
     ;; Start mu4e in fullscreen
     (defun my-mu4e-start ()
       (interactive)
       (window-configuration-to-register :mu4e-fullscreen)
       (mu4e)
       (delete-other-windows))
     ;; Restore previous window configuration
     (defun mu4e-quit-session ()
       "Restores the previous window configuration and kills the mu4e buffer"
       (interactive)
       (kill-buffer)
       (jump-to-register :mu4e-fullscreen))
     (use-package mu4e-contrib
       :config
       ;; html2text command from eww browser
       (setq mu4e-html2text-command 'mu4e-shr2text)
       ;; use aV to open message in browser
       (add-to-list 'mu4e-view-actions
                    '("ViewInBrowser" . mu4e-action-view-in-browser) t))
   #+END_SRC

** Helper for yasnippet
   
   This function helps with an expandable snippet. [[http://pragmaticemacs.com/emacs/email-templates-in-mu4e-with-yasnippet/][link]]


   #+BEGIN_SRC emacs-lisp
     ;; function to return first name of email recipients
     ;; used by yasnippet
     ;; inspired by
     ;;http://blog.binchen.org/posts/how-to-use-yasnippets-to-produce-email-templates-in-emacs.html
     (defun bjm/mu4e-get-names-for-yasnippet ()
       "Return comma separated string of names for an email"
       (interactive)
       (let ((email-name "") str email-string email-list email-name2 tmpname)
         (save-excursion
           (goto-char (point-min))
           ;; first line in email could be some hidden line containing NO to field
           (setq str (buffer-substring-no-properties (point-min) (point-max))))
         ;; take name from TO field - match series of names
         (when (string-match "^To: \"?\\(.+\\)" str)
           (setq email-string (match-string 1 str)))
         ;;split to list by comma
         (setq email-list (split-string email-string " *, *"))
         ;;loop over emails
         (dolist (tmpstr email-list)
           ;;get first word of email string
           (setq tmpname (car (split-string tmpstr " ")))
           ;;remove whitespace or ""
           (setq tmpname (replace-regexp-in-string "[ \"]" "" tmpname))
           ;;join to string
           (setq email-name
                 (concat email-name ", " tmpname)))
         ;;remove initial comma
         (setq email-name (replace-regexp-in-string "^, " "" email-name))

         ;;see if we want to use the name in the FROM field
         ;;get name in FROM field if available, but only if there is only
         ;;one name in TO field
         (if (< (length email-list) 2)
             (when (string-match "^\\([^ ,\n]+\\).+writes:$" str)
               (progn (setq email-name2 (match-string 1 str))
                      ;;prefer name in FROM field if TO field has "@"
                      (when (string-match "@" email-name)
                        (setq email-name email-name2))
                      )))
         email-name))
   #+END_SRC

** Sending mail
   #+BEGIN_SRC emacs-lisp
     (use-package smtpmail
       :if (executable-find "mu")
       :config
       (setq message-send-mail-ggfunction 'smtpmail-send-it
             smtpmail-stream-type 'starttls
             smtpmail-default-smtp-server "smtp.gmail.com"
             smtpmail-smtp-server "smtp.gmail.com"
             smtpmail-smtp-service 587
             send-mail-function 'smtpmail-send-it)
                                             ; warn if no attachments
       (defun mbork/message-attachment-present-p ()
         "Return t if an attachment is found in the current message."
         (save-excursion
           (save-restriction
             (widen)
             (goto-char (point-min))
             (when (search-forward "<#part" nil t) t))))

       (defcustom mbork/message-attachment-intent-re
         (regexp-opt '("I attach"
                       "I have attached"
                       "I've attached"
                       "I have included"
                       "I've included"
                       "see the attached"
                       "see the attachment"
                       "attached file"))
         "A regex which - if found in the message, and if there is no
     attachment - should launch the no-attachment warning.")

       (defcustom mbork/message-attachment-reminder
         "Are you sure you want to send this message without any attachment? "
         "The default question asked when trying to send a message
     containing `mbork/message-attachment-intent-re' without an
     actual attachment.")

       (defun mbork/message-warn-if-no-attachments ()
         "Ask the user if s?he wants to send the message even though
     there are no attachments."
         (when (and (save-excursion
                      (save-restriction
                        (widen)
                        (goto-char (point-min))
                        (re-search-forward mbork/message-attachment-intent-re nil t)))
                    (not (mbork/message-attachment-present-p)))
           (unless (y-or-n-p mbork/message-attachment-reminder)
             (keyboard-quit))))

       (add-hook 'message-send-hook #'mbork/message-warn-if-no-attachments)
       )

   #+END_SRC

** Alerts
#+BEGIN_SRC emacs-lisp
  (mu4e-alert-set-default-style 'libnotify)
#+END_SRC
* Feed reader (elfeed)

I use [[https://github.com/skeeto/elfeed][elfeed]] to manage some RSS links:

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "elfeed"
    (bind-keys
     :map elfeed-search-mode-map
     ("q" . bjm/elfeed-save-db-and-bury)))
  (spacemacs/set-leader-keys "af" #'bjm/elfeed-load-db-and-open)
  (setq elfeed-goodies/entry-pane-position 'bottom)
  ;; thanks - http://pragmaticemacs.com/emacs/read-your-rss-feeds-in-emacs-with-elfeed/
  ;; though slightly modified
  ;; functions to support syncing .elfeed between machines
  ;; makes sure elfeed reads index from disk before launching
  (defun bjm/elfeed-load-db-and-open ()
    "Load the elfeed db from disk before opening."
    (interactive)
    (elfeed)
    (elfeed-db-load)
    (elfeed-search-update--force)
    (elfeed-update))
  ;;write to disk when quiting
  (defun bjm/elfeed-save-db-and-bury ()
    "Wrapper to save the elfeed db to disk before burying buffer"
    (interactive)
    (elfeed-db-save)
    (quit-window))
  (setq-default elfeed-search-filter "@1-week-ago +unread ")

  ;; This lets me get the http links to entries with org-capture
  ;; easily.
  (defun elfeed-entry-as-html-link ()
    "Store an http link to an elfeed entry"
    (when (equal major-mode 'elfeed-show-mode)
      (let ((description (elfeed-entry-title elfeed-show-entry))
            (link (elfeed-entry-link elfeed-show-entry)))
        (org-store-link-props
         :type "http"
         :link link
         :description description))))
  (add-hook 'org-store-link-functions #'elfeed-entry-as-html-link)
#+END_SRC

* Keybindings
#+BEGIN_SRC emacs-lisp
  (bind-keys
   ("C-M-a" . sp-beginning-of-sexp)
   ("C-M-e" . sp-end-of-sexp)
   ("M-]" . sp-unwrap-sexp)) ; C-M-SPC is bound to mark-sexp
#+END_SRC
