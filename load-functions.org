This is a file to store some miscellaneous functions I use every now
and then. 

* Jekyll functions
I use ~jekyll-publish-draft~ to move a post from _drafts/ to _posts/
which publishes it to my blog. Inspiration from [[http://pasoev.github.io/programming/2015/10/31/jekyll-posts-emacs-capture/][here]]

#+BEGIN_SRC emacs-lisp
  (defun today-is ()
    "Return current year-month-day."
    (format-time-string "%Y-%m-%d"))

  (defun jekyll-drafts ()
    (let ((default-directory
            (concat (projectile-project-root) "_drafts")))
    (file-expand-wildcards "*.md")))

  (defun jekyll-publish-draft (post)
    "Mark one of the posts from the Jekyll drafts directory as published.
     This actually means moving the post from the _drafts to the _posts 
     directory."
    (interactive
     (list (completing-read "Post to publish: "
                            (jekyll-drafts) nil t "")))
    (copy-file (concat (projectile-project-root) "_drafts/" post)
               (concat (projectile-project-root) "_posts/" (today-is) "-" post))
    (delete-file (concat (projectile-project-root) "_drafts/" post)))

#+END_SRC

* Swap horizontal and vertical windows
Sometimes I want horizontal windows to be vertical or vice versa. This
lets me make that happen:

#+BEGIN_SRC emacs-lisp
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+END_SRC
* Splitting windows
  These functions make splitting windows behave more like I want it
  to. This way, calling ~C-x 2~ or ~C-x 3~ both splits the window
  /and/ shows the last buffer. 

#+BEGIN_SRC emacs-lisp
  (defun my/vsplit-last-buffer (prefix)
    "Split the window vertically and display the previous buffer."
    (interactive "p")
    (split-window-vertically)
    (other-window 1 nil)
    (if (= prefix 1)
      (switch-to-next-buffer)))
  (defun my/hsplit-last-buffer (prefix)
    "Split the window horizontally and display the previous buffer."
    (interactive "p")
    (split-window-horizontally)
    (other-window 1 nil)
    (if (= prefix 1) (switch-to-next-buffer)))
  (bind-key "C-x 2" 'my/vsplit-last-buffer)
  (bind-key "C-x 3" 'my/hsplit-last-buffer)
#+END_SRC
* Google
Google the marked region or ask:


#+BEGIN_SRC emacs-lisp
  (defun google ()
    "Google the selected region if any, display a query prompt otherwise."
    (interactive)
    (browse-url
     (concat
      "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
      (url-hexify-string (if mark-active
           (buffer-substring (region-beginning) (region-end))
           (read-string "Search Google: "))))))
#+END_SRC

* UT's VPN
I can connect to the VPN at UT-Austin with this function:

#+BEGIN_SRC emacs-lisp
  (defun utexas/vpn ()
    (interactive)
    (with-temp-buffer
      (cd "/sudo::/")
      (async-shell-command "openconnect vpn.utexas.edu")))
#+END_SRC

Now let's bind it to f3:


#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f3>") 'utexas/vpn)
#+END_SRC

* Calc
From [[https://www.reddit.com/r/emacs/comments/445w6s/whats_some_small_thing_in_your_dotemacs_that_you/][this reddit thread]]

#+BEGIN_SRC emacs-lisp
  (defun calc-eval-region (arg)
    "Evaluate an expression in calc and communicate the result.

  If the region is active evaluate that, otherwise search backwards
  to the first whitespace character to find the beginning of the
  expression. By default, replace the expression with its value. If
  called with the universal prefix argument, keep the expression
  and insert the result into the buffer after it. If called with a
  negative prefix argument, just echo the result in the
  minibuffer."
    (interactive "p")
    (let (start end)
  (if (use-region-p)
      (setq start (region-beginning) end (region-end))
    (progn
      (setq end (point))
      (setq start (search-backward-regexp "\\s-\\|\n" 0 1))
      (setq start (1+ (if start start 0)))
      (goto-char end)))
  (let ((value (calc-eval (buffer-substring-no-properties start end))))
    (pcase arg
      (1 (delete-region start end))
      (4 (insert " = ")))
    (pcase arg
      ((or 1 4) (insert value))
      (-1 (message value))))))
#+END_SRC

* Insert file name

This function ([[http://pragmaticemacs.com/emacs/insert-file-name/][credit]]) lets me insert a file name easily. Defaults to
relative patph, use the universal argument to get the absolute path.

#+BEGIN_SRC emacs-lisp
  (defun my/insert-file-name (filename &optional args)
    "Insert name of file FILENAME into buffer after point.

    Prefixed with \\[universal-argument], expand the file name to
    its fully canocalized path.  See `expand-file-name'.

    Prefixed with \\[negative-argument], use relative path to file
    name from current directory, `default-directory'.  See
    `file-relative-name'.

    The default with no prefix is to insert the file name exactly as
    it appears in the minibuffer prompt."
    ;; Based on insert-file in Emacs -- ashawley 20080926
    (interactive "*fInsert file name: \nP")
    (cond ((eq '- args)
           (insert (expand-file-name filename)))
          ((not (null args))
           (insert (filename)))
          (t
           (insert (file-relative-name filename)))))
#+END_SRC
